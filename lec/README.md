**Лекция** 1: **Введение в разработку мобильных приложений
Аннотация:** Целью лекции является описание основных принципов
разработки для ОС Android. В лекции рассказывается об устройстве
платформы Android, приводится обзор сред программирования, описываются
возможности отладки на эмуляторах и реальных устройствах. Имеется
большое количество разнообразных примеров и иллюстраций. В конце
приведен список дополнительных источников. Лекция является обязательной
для понимания следующих тем курса.

```
1.1 Введение
```
Android - операционная система для мобильных устройств: смартфонов,
планшетных компьютеров, КПК. В настоящее время именно Android является
самой широко используемой операционной системой для мобильных
устройств. Подтверждение этого факта можно найти в таблице 1 ,
составленной по данным аналитической компании Gartner.
Таблица 1.
Мировые продажи смартфонов конечным пользователям,
распределение по ОС
**Операционная
система**

```
Продано
(тыс.ед.) III кв.
2013
```
```
Доля рынка
(%) III кв. 2013
```
```
Продано
(тыс.ед.) III кв.
2012
```
```
Доля рынка
(%) III кв. 2012
Android 205022,7 81,9 124552,3 72,
iOS 30330,0 12,1 24620,3 14,
Microsoft 8912,3 3,6 3993,6 2,
BlackBerry 4400,7 1,8 8946,8 5,
Bada 633,3 0,3 4454,7 2,
Symbian 457,5 0,2 4401,3 2,
другие 475,2 0,2 683,7 0,
Общее кол - во: 250231,7 100,0 171652,7 100,
```
Внимательное изучение таблицы позволяет увидеть подавляющую
популярность смартфонов под управлением ОС Android в мире, доля таких
устройств не первый год превышает половину от общего числа купленных
смартфонов. Кроме всего прочего, эта популярность продолжает расти.


Очевидно, что армия пользователей смартфонов под управлением Android
будет искать дополнительные приложения для своих устройств, в связи с этим
умение разрабатывать эти самые приложения может принести много пользы
своему владельцу. Например, можно разрабатывать для себя полезные,
интересные, занимательные (нужное подчеркнуть) приложения, а можно,
разведав обстановку и осмотревшись, сделать разработку мобильных
приложений своей профессиональной деятельностью, основной или
дополнительной.
Курс "Разработка приложений для смартфонов на ОС Android"
предоставляет возможность приобрести начальные навыки разработки
мобильных приложений, если остановиться только на первой его части.
Изучение полной версии курса позволит сделать серьезный шаг к тому, чтобы
профессионально разрабатывать мобильные приложения и получать от этой
деятельности не только моральное, но и материальное удовлетворение.
Данная лекция является первой для всего курса, призвана ввести
читателя в курс дела. В первую очередь в ней рассматриваются вопросы
становления и развития ОС Android. Для успешного программирования под
Android необходимо понимать внутреннюю организацию и архитектуру этой
платформы, а также полезно знать, какие инструменты и среды разработки
можно использовать. Этим вопросам посвящена основная часть лекции. Кроме
того, в лекции рассматриваются особенности запуска и отладки мобильных
приложений.

```
Немного истории
```
Рассмотрим, как все начиналось. В 2003 году в Пало Альто, штат
Калифорния Энди Рубин с единомышленниками (Рич Майнер, Ник Сирс и
Крис Уайт) основали компанию Android Inc. Поначалу в компании занимались
проектированием мобильных гаджетов, которые на основе геолокационных
данных автоматически подстраивались под нужды пользователей.


В августе 2005 года Android Inc. стала дочерней компанией Google. Энди
Рубин, Рич Майнер и Крис Уайт остались в Android Inc. и начали работать над
операционной системой, базирующейся на ядре Linux. В Google задумали
реализовать мощнейшую платформу, пригодную к использованию на тысячах
различных моделей телефонов. В связи с этим был создан Open Handset
Alliance (OHA) - консорциум, состоящий из более 80 компаний,
направляющий свои усилия на разработку открытых стандартов для
мобильных устройств. В состав OHA входят такие гиганты, как Google
(организатор и идейный вдохновитель), HTC, Sony, Dell, Intel, Motorola,
Qualcomm, Texas Instruments, Samsung Electronics, LG Electronics, T-Mobile,
Sprint Corporation, NVIDIA и многие другие.
Первая версия Android была представлена 23 сентября 2008 года, версии
было дано название Apple Pie (можно заметить созвучие с прямым
конкурентом). Далее так повелось, что название каждой очередной версии
представляет какой-либо десерт, при этом первые буквы наименований в
порядке версий соответствуют буквам латинского алфавита по порядку. С
развитием обновлений Android можно познакомиться в таблице 2.
Таблица 2.
История обновлений ОС Android
**Версия, логотип,
дата выхода Основные возможности**^
Android 1.

```
Apple Pie
```
```
Первый стабильный релиз, основан на ядре Linux 2.6.25.
Поддерживается:
```
- файловая система FAT32, стек интернет-протоколов TCP/IP;
- протоколы передачи данных: 802.11 b/g Wi-Fi,Bluetooth 2.0 EDR,
    GPRS, EDGE, UMTS, HSDPA;
- фото и видео съемка, однако недостаточно опций для настройки
    разрешения камеры, баланса белого и др.;
- сенсорные дисплеи и landscape режим отображения данных на экране,
    максимальная цветность дисплея - 16 бит (тип HVGA);
- виджеты и ярлыки на рабочем столе (Home Screen), сменные обои;
- регулярные телефонные функции, контроль вызова, конференц-связь,
    легкая интеграция с контактами;
- полноценный web-браузер на движке WebKit, HTML, XHTML;
- e-mail клиент, протоколы POP3, IMAP4, SMTP;
- медиа проигрыватель, позволяющий управлять, импортировать,
    проигрывать медиа контент в различных форматах.


Базовые приложения:
будильник; калькулятор; календарь; камера; контакты; сообщения (в
том числе MMS); настройки; голосовой набор.
Минимальные системные требования для запуска и работы:
архитектура ARM, 128 MB RAM, 256 MB ROM.
Видео презентация:
[http://www.youtube.com/watch?feature=player_embedded&v=1FJHYqE0R](http://www.youtube.com/watch?feature=player_embedded&v=1FJHYqE0R)
Dg^
Android 1.

Banana Bread
февраль 2009
(API level: 2)^

```
Нововведения:
Исправлены проблемы: с будильником; со спящим режимом; с вызовом
дисплея набора номера; в IMAP ошибки запроса пароля и др.
Изменения API.
Добавлены подробности и отзывы к картам.
Добавлена поддержка вложений из MMS.
Локализации:
Английская US (en_US)
Немецкая (de)
Подробности:
http://developer.android.com/about/versions/android-1.1.html^
Android 1.
Cupcake
```
апрель 2009
(API level: 3)^

Нововведения:
Поддержка экранной клавиатуры (портретный и книжный режимы);
акселерометра; видеозапись и воспроизведение видео; приложение для
работы с YouTube; стерео Bluetooth; функция копирования и вставки
между приложениями (copy&paste).
Локализации:
добавились очень многие, в том числе и русская (ru_RU).
Система:
новое Linux ядро (версия 2.6.27); автоматическая проверка и
восстановление файловой системы на SD card; новое приложение для
просмотра СТК меню оператора (SIM Application Toolkit 1.0).
Изменения в пользовательском интерфейсе (UI):
изменено большинство UI-элементов, добавлены новые виджеты;
определение режима (книжный или портретный) работы программы;
анимированное переключение между окнами.
Подробности:
[http://developer.android.com/about/versions/android-1.5.html](http://developer.android.com/about/versions/android-1.5.html)^
Android 1.

Donut
сентябрь 2009
(API level: 4)^

```
Нововведения:
Система:
новое ядро Linux (версия 2.6.29); поддержка сотового стандарта CDMA;
поддержка разрешений дисплеев: QVGA и WVGA; обновленный медиа-
движок OpenCore 2; движок синтеза речи (многоязыковой); Gesture
Builder поддержка возможности (для разработчиков) создавать,
сохранять, загружать и распознавать жесты, прикреплять к
определенным действиям.
Пользовательские возможности:
строка быстрого поиска (прямо с рабочего стола): история и закладки в
браузере, контакты и поиск в интернете; возможность подключаться к
видам VPN: L2TP/IPSEC pre-shared key based VPN, L2TP/IPSEC
certificate based VPN, L2TP only VPN, PPTP only VPN; ускорение работы
```

```
камеры; индикатор работы батареи позволяет увидеть сколько энергии
потребляют работающие программы и сервисы.
Обновленный Android Market.
Подробности:
http://developer.android.com/about/versions/android-1.6.html^
Android 2.0,
2.0.1, 2.
```
Eclair
октябрь 2009
(API level: 5)
(API level: 6)
(API level: 7)^

Нововведения в 2.0:
поддержка работы нескольких почтовых аккаунтов одновременно,
возможность использования совместных папок (входящие, исходящие)
для всех аккаунтов; быстрый способ работы с контактами Quick Contact;
поиск по всем сохраненным SMS и MMS сообщениям, удаление старых
после заданного срока;
возможности камеры: вспышка, цифровой зум, сценические режимы,
баланс белого, цветовые эффекты, макрофокусировка;
улучшенное расположение виртуальных клавиш клавиатуры, поддержка
комбинированных нажатий клавиш (технология мультитач),
усовершенствованная функция автодополнения;
поддержка HTML5, версии Bluetooth 2.1, новых профилей OPP и PBAP.
Подробности:
[http://developer.android.com/about/versions/android-2.0.html](http://developer.android.com/about/versions/android-2.0.html)
Нововведения 2.0.1:
подрелиз версии 2.0, включающий в себя незначительные изменения в
функционале и по большей части bugfix-ом версии 2.0.
Подробности:
[http://developer.android.com/about/versions/android-2.0.1.html](http://developer.android.com/about/versions/android-2.0.1.html)
Нововведения 2.1:
основным новшеством, представляющим интерес для конечного
пользователя, стало добавление анимированных (живых) обоев,
остальные изменения в Framework API, представляют интерес для
разработчиков.
Подробности:
[http://developer.android.com/about/versions/android-2.1.html](http://developer.android.com/about/versions/android-2.1.html)^
Android 2.

Froyo
май 2010
(API level: 8)^

```
Нововведения:
рост производительности примерно в 3-5 раз за счет использования
Dalvik Virtual Machine Just-in-Time компилятора (Dalvik устарел, вместо
него используется ART);
возможности установки приложений на SD-карту, переноса
приложений из внутренней памяти на карту и обратно;
возможность использовать смартфон в качестве точки доступа к
интернету, в качестве модема для других устройств;
поддержка Adobe Flash;
V8 javascript существенно повысил скорость работы штатного браузера.
Подробности:
http://developer.android.com/about/versions/android-2.2.html^
Android 2.3,
2.3.
```
```
Gingerbread
```
```
До весны 2013 года самая массовая версия на рынке.
Нововведения:
новое ядро Linux 2.6.35; поддержка открытых мультимедийных
стандартов (VP8 и WebM), форматов ACC/AMR, звуковых эффектов и
эквалайзера, фронтальной камеры (интеграция с VOIP(SIP));
обновленный GUI: уменьшение времени доступа к функциям,
повышение общей энергоэффективности системы;
```

декабрь 2010
(API level: 9)
(API level: 10)^

улучшение стандартной клавиатуры системы: поддержка словарей,
технологии мультитач, упрощенное выделение и копирование текста;
поддержка технологии NFC; расширение возможностей работы с
датчиками положения телефона.
Подробности:
[http://developer.android.com/about/versions/android-2.3.html](http://developer.android.com/about/versions/android-2.3.html)^
Android 3.0-3.

Honeycomb
февраль 2011
(API level: 11)
(API level: 12)
(API level: 13)^

```
Специальная версия для работы на планшетах (MID, tablets).
Нововведения 3.0:
новое ядро Linux 2.6.36; поддержка файловой системы ext4, файловой
системы FUSE для MTP устройств; поддержка режима USB-хост для
работы с клавиатурой, мышью и USB-хабами; поддержка MTP/PTP;
виртуальная машина Dalvik: поддержка и оптимизация SMP, множество
улучшений JIT, улучшенный сборщик мусора;
совершенно новый интерфейс с полноценной оптимизацией под
устройства с большими экранами; поддержка виртуальных рабочих
столов, каждый из которых может иметь свой набор виджетов и
ярлыков;
улучшенные и переработанные базовые приложения: Browser, e-mail и
др.
Подробности:
http://developer.android.com/about/versions/android-3.0.html
Нововведения 3.1:
поддержка работы кардридера;
усовершенствован GUI: доработан менеджер задач, позволяющий
переключаться между множеством различных приложений (в 3.0 только
5 программ одновременно); возможность менять размер виджетов, как
по горизонтали, так и по вертикали.
Подробности:
http://developer.android.com/about/versions/android-3.1.html
Нововведения 3.2:
расширен спектр поддерживаемых планшетов; возможность
автоматического масштабирования приложений для отображения на
более крупных экранах.
Подробности:
http://developer.android.com/about/versions/android-3.2.html^
Android 4.0,
4.0.
Ice Cream
Sandwich
```
ноябрь 2011
(API level: 14)
(API level: 15)^

```
Нововведения:
поддержка и смартфонов, и планшетов; поддержка новых процессорных
архитектур, помимо ARM поддержка Intel x86 и MIPS;
возможность разблокировки экрана: при помощи функции определения
лица; жестами: перетащить замочек из центра экрана на иконку
приложения и оно запустится;
многозадачность: кнопка Recent Apps позволяет мгновенно переходить
от одной задачи к другой с помощью списка в системной панели;
новые элементы управления передачей данных через сеть: в
приложении Настройки можно увидеть общее использование данных по
каждому типу сети, объем данных, используемых каждым работающим
приложением;
доступность Android 4.0 для слепых и слабовидящих пользователей,
браузер поддерживает экранного чтеца, который воспроизводит все
видимое активное содержимое на экране;
```

AndroidBeam - удобное средство обмена между двумя NFC-
устройствами;
Wi-Fi Direct и Bluetooth HDP, HFP: возможность прямого подключения
к соответствующим устройствам.
Подробности:
[http://developer.android.com/about/versions/android-4.0.html](http://developer.android.com/about/versions/android-4.0.html)^
Android 4.1-4.

Jelly Bean
июль 2012
(API level: 16)
(API level: 17)
(API level: 18)^

Нововведения 4.1:
увеличена скорость прорисовки интерфейса, улучшен поиск, добавлено
несколько полезных сервисов;
улучшена работа со словарями, возможно использовать голосовой ввод
без подключения к интернету;
специальные возможности: возможность управления смартфоном с
помощью жестов и голосовых подсказок, подключения устройств ввода,
поддерживающих шрифт Брайля;
существенно доработана функция передачи данных Beam; переработан
поиск (вместо ссылок ответ на запрос); голосовой поиск; Google Now:
нужная информация в нужное время.
Подробности:
[http://developer.android.com/about/versions/android-4.1.html](http://developer.android.com/about/versions/android-4.1.html)
Нововведения 4.2:
реализована поддержка нескольких пользователей (планшеты);
поддержка wireless display: возможность трансляции видео и
изображений на внешний экран; возможность отображения полезной
информации в режиме сна, при подключении к док-станции или на
зарядке; улучшена панель уведомлений.
Подробности:
[http://android.com.ua/android_42.html](http://android.com.ua/android_42.html)
Нововведения 4.3:
ускорение работы системы; более точный набор на клавиатуре; скрытая
возможность управления процессами программ (необходима
активация); поддержка OpenGL/ES 3.0 (не на всех устройствах).
Подробности:
[http://developer.android.com/about/versions/android-4.3.html](http://developer.android.com/about/versions/android-4.3.html)^
Android 4.

Kit Kat
октябрь 2013
(API level: 19)^

Нововведения:
многозадачность, оптимизация распределения ресурсов между
приложениями; определитель номера работает не только с адресной
книгой (например, Google maps); серьезная интеграция приложения
Hangouts (отправка SMS, MMS, голосовые и видеовызовы); в состав
вошел Quickoffice, интегрированный с Google Drive; поддержка
принтеров, подключение через приложения поддерживающие печать
(например, Google Cloud Print, HP ePrint); поддержка стандарта Wi-Fi
Miracast, позволяющий вещать изображение на телевизор; возможность
захвата экрана для записи видео.
Подробности:
[http://developer.android.com/about/versions/android-4.4.html](http://developer.android.com/about/versions/android-4.4.html)^
Android 5.0 / 5.

Lollipop

```
5.
Основная статья: Android Lollipop
```
- «Material design» — новая составляющая пользовательского
интерфейса, которая основана на простоте, яркости, понятности и
функциональности.


3 ноября 2014

- Появился Project Volta, благодаря которому операционная система
обращается к процессору не одиночными запросами, а пакетами
данных, тем самым экономя заряд, в результате чего Nexus 5 может
работать на 1,5 часа дольше.
- Уведомления на экране блокировки. Чтобы открыть одно из
уведомлений, нужно два раза нажать по нему
- Теперь вместо компилятора Dalvik используется компилятор ART.
- Ambient display — функция, при которой при взятии Nexus
6 или Nexus 9 в руки сразу включается дисплей, показывающий
важные уведомления.
- Smart lock.
- В меню быстрых настроек добавлен фонарик.
- Переработан режим авторегулировки яркости экрана.
- В меню «О телефоне» появилась возможность оставить отзыв об
устройстве.(Nexus)
- Появилась возможность запуска камеры и «звонилки» с экрана
блокировки.
- Полноценный менеджер пользователей.
- Можно настраивать оповещения приложений, отключая их, если
даже такой опции нет в самой программе.
- Новый интерфейс смены запущенных приложений.
5.0.
- Исправлены ошибки
5.0.
- Исправлены ошибки
5.
- Исправлены ошибки.
- Улучшена стабильность системы.
- Улучшена шторка, интуитивный интерфейс для быстрого выбора
сети Wi-Fi и Bluetooth.
- Поддержка работы с двумя SIM-картами (ранее производителям
приходилось реализовывать эту функцию собственными силами), для
каждой SIM-карты можно будет создавать свой профиль с
определенным цветом, в который будет окрашиваться цвет
стандартной "звонилки" для быстрого распознавания используемой
SIM-карты.
- Поддержка HD Voice (при условии, что технология поддерживается
оператором и «железом» смартфона).
- Новая система защиты смартфона и системы Device Protection
(Device Protection блокирует смартфон или планшет в случае кражи
или потери, делая его фактически бесполезным до тех пор, пока
настоящий владелец не пройдет верификацию Google-аккаунта и не
снимет программную блокировку).
    - Новый жест для "вежливых уведомлений", смахнув уведомление
       вверх останется напоминание о пропущенном событии.
5.1.
    - Исправлена ошибка с "утечкой" памяти.
    - Добавлен встроенный сервис VPN от Google для большей
       безопасности при подключении к открытым сетям Wi-Fi (только
       для Nexus).
Android 6.0 6.
Основная статья: Android Marshmallow


Marshmallow^
28 мая 2015

- мобильная платежная система Android Pay и стандартизированная
    верификация при помощи отпечатков пальцев на уровне
    платформы. Для устройств, оснащенных сканером отпечатка, будет
    доступна разблокировка гаджета и авторизация покупок в Google
    Play, а разработчики смогут встраивать соответствующий API в
    любые Android-приложения.
- Также Google уделила много внимания экономии заряда
    аккумулятора — именно в этой сфере Android-устройства часто
    подвергаются критике. Функция Doze работает за счет сенсора
    движения: когда устройство находится в покое долгое время,
    активируется "глубокий спящий" режим, активность приложений в
    фоновом режиме сильно ограничивается, что сохраняет заряд
    батареи.
- Google также обещала пользователям больше контроля над тем, как
    приложения используют их данные, — запросы на работу с
    информацией будут отправляться не в момент установки, а
    непосредственно в ходе использования приложения.
- Новая функция Chrome custom tabs призвана сделать более удобным
    потребление веб-контента на мобильном. Всего в Android M будет
    около 100 новых функций, заявил вице-президент Google Дэвид
    Бюрке.
6.0.
- Исправлены ошибки.
- Исправлена проблема с системными часами.
- Более 200 новых смайликов.
- Функция быстрого запуска камеры двойным нажатием кнопки
    питания.
Android 7.0 / 7.

Nougat
22 августа 2016

```
7.
Основная статья: Android Nougat
```
- Android 7.0 Nougat получила режим многооконного разделения
    экрана, в котором два приложения могут занять две половины
    экрана.
- Добавлена кнопка «Очистить все» (Clear All) в списке запущенных
    приложений.
- Значки быстрого доступа теперь выводятся на компактной панели.
- Реализована фильтрация входящих звонков по телефонному
    номеру.
- Улучшены уведомления, появилась возможность быстрого ответа.
- Фоновое переключение задач: все открытые приложения и
    выполняемые операции можно быстро вывести на основной экран с
    помощью кнопки «Обзор». Двойное нажатие открывает
    предыдущую задачу, а удерживание позволяет выбрать нужную
    среди всех доступных. Подобная функция успешно используется в
    Windows с помощью комбинации Alt + Tab.
- Ночной режим позволяет добиться оптимального отображения
    информации на экране с помощью автоматического повышения
    контрастности и регулировки яркости.
- Уведомления одного приложения могут быть объединены.
- Усовершенствована функция энергосбережения «Doze». Ранее она
    работала только когда телефон был неподвижен, но теперь Google
    утверждает, что "Doze экономит батарею всякий раз, когда экран
    выключается".


- Новый «Data Saver» режим ограничивает использование мобильных
    данных в фоновом режиме и может вызвать внутренние функции в
    приложениях, которые предназначены для уменьшения
    использования пропускной способности, к примеру сжатие качества
    потокового мультимедиа.
- Новый дизайн папок. Значки внутри рамки выстроены в сетку.
- Поддержка режима «картинка в картинке».
- 72 новых emoji.
- Полноценная аппаратная поддержка режима виртуальной
    реальности.
7.
- Режим Daydream VR. Daydream VR анонсировали еще на Google I/O
    2016, но появится режим виртуальной реальности только с Android
    7.1. Пока что только для смартфонов Pixel и Pixel XL.
- App shortcuts API. После многочисленных утечек Google
    официально представили «ярлыки для приложений». Ярлыки
    позволяют производить основные действия с приложением еще до
    его запуска. Вы можете создать до 5 ярлыков для одного
    приложения.
7.1.
- Поддержка круглых иконок для приложений. Позволяет привести
    все иконки к единому дизайну, соответствующему новому Pixel
    Launcher.
- Image Keyboard Support. Расширяет виды контента, которые
    пользователи могут вводить с помощью клавиатуры. Позволяет
    использовать стикеры, gif-изображения и много другое прямо из
    вашей клавиатуры. Приложения могут «сказать», какой тип
    контента они принимают, а клавиатура может предоставить этот
    контент пользователю.
- Storage manager Intent. Дает пользователю доступ к новой части
    настроек, где вы можете узнать, какие файлы и приложения
    используют вашу память, удалить неиспользуемые файлы и
    освободить место на вашем устройстве.
- Поддержка Daydream.
- Контекстное меню для ярлыков приложений, вызываемое по
    долгому нажатию на иконку (программный аналог 3D Touch).
- Другие функции, которые пока доступны только владельцам Google
    Pixel и Pixel XL.
7.1.
- Улучшение шифрования.
- Исправления ошибок и небольшие улучшения программного кода.
- Новые настройки живых обоев.
- Позволяет пользователям решать, где применять живые обои.
    - Поддержка жестов по сканеру отпечатков пальцев для Nexus 5X и
       Nexus 6P.

Android 8.0 / 8.

Oreo

```
8.
Основная статья: Android Oreo
```
- Новые уведомления.
    Они получили новый дизайн, как это произошло в Android 7.
    Nougat.


21 августа 2017 • Бейджи на иконках.
Над иконками приложений на рабочем столе будут отображаться
количество новых событий в программе. Это позволит
пользователю быстро оценить состояние приложения, посмотрев на
его иконку.

- «Картинка в картинке».
    Будет возможность смотреть видео в оконном режиме, на
    планшетах и смартфонах. Суть режима будет заключаться в
    минимизированном окне воспроизведения видео, которое будет
    располагаться поверх всех приложений на экране. Таким образом,
    например, можно будет смотреть YouTube и одновременно
    пользоваться другими сервисами.
- Ограничение фоновых процессов.
    В новой версии браузера Google Chrome 57 появилась технология,
    которая ограничивает нагрузку на процессор для неактивных
    вкладок. Следовательно будет более автономная работа — действие
    фоновых процессов будет дополнительно ограничиваться ради
    экономии заряда.
- Динамические иконки.
    В новой версии приложения смогут менять иконки без обновления
    всего приложения. Это дает возможность приложениям отображать
    свой статус с помощью иконки.
- Ранее сообщалось, что в Android 8.0 появятся функция Gboard Copy
    Less, которая будет предугадывать, когда пользователь пытается
    отправить адрес найденного объекта в другом приложении. Как
    только будет набран указывающий на это фрагмент текста «it’s at»,
    Gboard покажет соответствующую подсказку.
- Другое нововведение Android 8.0 — автоматическая вставка связей
    с подходящими по контексту приложениями. Например,
    встретившийся в сообщении электронной почты телефонный номер
    будет связан с окном набора номера, адрес откроет приложение
    карт, а дата — календарь.
- Еще одна опция Android 8.0 заключается в распознавании экранных
    жестов, открывающих в любой ситуации соответствующее
    приложение. Например, чтобы открыть календарь, достаточно
    будет изобразить пальцем на экране букву C.
8.
- API нейронных сетей
- API общей памяти
- API WallpaperColors
- Уровень заряда батареи Bluetooth для подключенных устройств,
    доступный в быстрых настройках
- Android Go, дополнительный легкий дистрибутив Android для
    устройств младшего класса с объемом памяти менее 1 ГБ
- Обновления структуры автозаполнения
- Программные действия безопасного просмотра
- Кнопки навигации тускнеют, когда не используются
- Визуальные изменения в «Power Off» и «Restart», включая новый
    экран и плавающую панель инструментов
- Тост-уведомления теперь белого цвета с одинаковой прозрачностью
- Автоматические светлые и темные темы


- Дополнительная поддержка чипов изображений для устройств Pixel
    2
- Новое пасхальное яйцо в виде официального изображения печенья
    Oreo
- Исправлены эмодзи гамбургера, сыра, и пива.
Android 9

Pie
6 августа 2018

- Новый пользовательский интерфейс для быстрого меню настроек.
- Часы сдвинулись влево от панели уведомлений.
- «Док» теперь имеет полупрозрачный фон.
- Заставка батареи больше не отображается оранжевым наложением на
    панели уведомлений и состояния.
- К параметрам питания добавлена кнопка «Снимок экрана».
- Новый режим блокировки, который отключает биометрическую
    аутентификацию после активации.
- Закругленные углы в пользовательском интерфейсе.
- Новые переходы для переключения между приложениями или
    действия в приложениях.
- Более богатые уведомления о сообщениях, где полная беседа может
    быть получена в уведомлении, полномасштабных изображениях и
    умных ответах, похожих на новое приложение Google, "Reply".
- Поддержка вырезов в дисплее.
- Переработанный ползунок громкости.
- Аккумулятор теперь отображается в режиме постоянного включения.
- Изменения безопасности блокировки экрана включают возможный
    возврат улучшенной NFC Unlock.
- Экспериментальные функции (которые в настоящее время скрыты в
    меню под названием Feature Flags), например, обновленная страница
    «О телефоне» в настройках и автоматическое включение Bluetooth во
    время вождения.
- DNS поверх TLS
- Новый дополнительный системный интерфейс на основе жестов,
    позволяющий пользователям перемещаться по ОС с помощью swipes
    чаще, чем традиционный пользовательский интерфейс
- Обновлен многозадачный коммутатор приложений с панелью поиска
    Google и ящиком приложений.
- Android Dashboard, которая сообщает пользователю, сколько времени
    вы тратите на свое устройство и в приложениях, и позволяет
    пользователю устанавливать ограничения по времени для приложений
- «Шуш», расширенная версия режима «Не беспокоить» активирована,
    поместив телефон лицевой стороной вниз, что отключает стандартные
    уведомления
- «Адаптивная батарея», которая использует Doze для спячки
    пользовательских приложений, ОС определяет, что пользователь не
    будет использовать
- Функция автоматической яркости изменяет яркость экрана на основе
    пользовательских привычек
- Функция Wind Down позволяет пользователям Android устанавливать
    определенное время сна, при котором включается режим «Не
    беспокоить» и весь интерфейс телефона делается серым, чтобы
    препятствовать дальнейшему использованию в ночное время
- Поддержка Vulkan 1.
Android 10
- Встроенная поддержка складных телефонов
- Новые и улучшенные настройки пользовательского интерфейса со
сменными темами, значками и шрифтами.
- Позволяет пользователям контролировать, когда приложения имеют
разрешение на просмотр своего местоположения: никогда, только


```
3 сентября 2019 когда приложение используется (работает) или постоянно (в фоновом режиме).
```
- Новые разрешения для доступа к фоновым фотографиям, видео и
    аудиофайлам.
- Встроенный рекордер экрана.
- Фоновые приложения больше не могут прыгать на передний план.
- Улучшенная конфиденциальность: ограниченный доступ к не
    сбрасываемым идентификаторам устройств.
- Обмен ярлыками, позволяющими делиться контентом с контактом
    напрямую.
- Плавающая панель настроек, позволяющая изменять настройки
    системы прямо из приложений.
- Динамический формат глубины для фотографий, который позволяет
    изменять размытие фона после съемки.
- Поддержка видеокодека AV1, видео формата HDR10 + и аудиокодека
    Opus.
- Встроенный MIDI API, позволяющий взаимодействовать с
    музыкальными контроллерами.
- Улучшенная поддержка биометрической аутентификации в
    приложениях
Android 11

```
20 Февраля^2020
```
- Поддержка 5G.
- Улучшенная поддержка складных телефонов.
- Поддержка новых типов экранов.
- Обновления компонентов системы через Google Play — «Project
    Mainline».
- Улучшенная совместимость приложений.
- Новые возможности общения.
- Улучшенная поддержка нейросетей.
- Конфиденциальность и безопасность.
- Изменения в области связи, камеры и производительности:
    - Улучшения в области фильтрации звонков — через статус
       подтверждения STIR / SHAKEN для входящего вызова.
    - Улучшенный API по выбору оптимального Wi-Fi соединения
    - Поддержка анимированных файлов формата HEIF на системном
       уровне, для экономии данных и уменьшения размера apk.
    - Встроенный декодер изображений, новые API-интерфейсы NDK
       позволяют приложениям декодировать и кодировать изображения:
       JPEG, PNG, WebP, сохраняя при этом меньший размер APK.
    - Отключение звука во время захвата камеры — новые API для
       отключения вибрации звонков, сигналов будильника или
       уведомлений во время записи.
    - Декодирование видео с низкой задержкой в MediaCodec:
       минимальные задержки при декодировании видео, актуально для
       Google Stadia.
    - Режим HDMI с низкой задержкой — новые API для запроса
       автоматического режима с низкой задержкой известного также как
       «игровой режим» на внешних дисплеях и телевизорах.

**1.2 Устройство платформы Android**
Платформа Android объединяет операционную систему, построенную на
основе ядра ОС Linux, промежуточное программное обеспечение и
встроенные мобильные приложения. Разработка и развитие мобильной


платформы Android выполняется в рамках проекта AOSP (Android Open Source
Project) под управлением OHA (Open Handset Alliance), руководит всем
процессом поисковый гигант Google.
Android поддерживает фоновое выполнение задач; предоставляет
богатую библиотеку элементов пользовательского интерфейса; поддерживает
2D и 3D графику, используя OpenGL стандарт; поддерживает доступ к
файловой системе и встроенной базе данных SQLite.
С точки зрения архитектуры, система Android представляет собой
полный программный стек, в котором можно выделить следующие уровни:

- **Базовый уровень (Linux Kernel)** - уровень абстракции между
аппаратным уровнем и программным стеком;
- **Набор библиотек и среда исполнения (Libraries & Android**
Runtime) обеспечивает важнейший базовый функционал для приложений,
содержит виртуальную машину Dalvik и базовые библиотеки Java
необходимые для запуска Android приложений;
- **Уровень каркаса приложений (Application**
Framework) обеспечивает разработчикам доступ к API, предоставляемым
компонентами системы уровня библиотек;
- **Уровень приложений (App** lications) - набор предустановленных
базовых приложений.
Наглядное изображение архитектуры на рисунке 1.


```
Рис. 1. Архитектура Android
```
Рассмотрим компоненты платформы более подробно.
В основании компонентной иерархии лежит ядро ОС Linux 2.
(несколько урезанное), служит промежуточным уровнем между аппаратным и
программным обеспечением, обеспечивает функционирование системы,
предоставляет системные службы ядра: управление памятью, энергосистемой
и процессами, обеспечение безопасности, работа с сетью и драйверами.
Уровнем выше располагается набор библиотек и среда исполнения.
Библиотеки реализуют следующие функции:

- предоставляют реализованные алгоритмы для вышележащих уровней;
- обеспечивает поддержку файловых форматов;
- осуществляет кодирование и декодирование информации (например,
мультимедийные кодеки);
- выполняет отрисовку графики и т.д.


Библиотеки реализованы на С/С++ и скомпилированы под конкретное
аппаратное обеспечение устройства, вместе с которым они и поставляются
производителем в предустановленном виде.
Рассмотрим некоторые библиотеки:
Surface
Manager

- композитный менеджер окон. Поступающие команды отрисовки
собираются в закадровый буфер, где они накапливаются, составляя некую
композицию, а потом выводятся на экран. Это позволяет системе создавать
интересные бесшовные эффекты, прозрачность окон и плавные переходы.
Media
Framework
- библиотеки, реализованные на базе PacketVideo OpenCORE.
Используются для записи и воспроизведения аудио и видео контента, а
также для вывода статических изображений. Поддерживаются форматы:
MPEG4, H.264, MP3, AAC, AMR, JPG и PNG.
SQLite - легковесная и производительная реляционная СУБД, используется в
Android в качестве основного движка для работы с базами данных.
**3D библиотеки** - используются для высокооптимизированной отрисовки 3D-графики, при
возможности используют аппаратное ускорение. Библиотеки реализованы
на основе API OpenGL|ES. OpenGL|ES (OpenGL for Embedded Systems) -
подмножество графического программного интерфейса OpenGL,
адаптированное для работы на встраиваемых системах.
FreeType - библиотека для работы с битовыми картами, для растеризации шрифтов
и осуществления операций над ними.
LibWebCore - библиотеки браузерного движка WebKit, используемого также в
известных браузерах Google Chrome и Apple Safari.
SGL (Skia
Graphics
Engine)
- открытый движок для работы с 2D-графикой. Графическая библиотека
является продуктом Google и часто используется в других программах.

```
SSL - библиотеки для поддержки одноименного криптографического
протокола.
Libc - стандартная библиотека языка С, а именно ее BSD реализация,
настроенная для работы на устройствах на базе Linux.
```
Среда исполнения включает в себя библиотеки ядра, обеспечивающие
большую часть низкоуровневой функциональности, доступной библиотекам


ядра языка Java, и виртуальную машину Dalvik, позволяющую запускать
приложения. Каждое приложение запускается в своем экземпляре
виртуальной машины, тем самым обеспечивается изоляция работающих
приложений от ОС и друг от друга. Для исполнения на виртуальной машине
Dalvik Java-классы компилируются в исполняемые файлы с расширением .dex
с помощью инструмента dx, входящего в состав Android SDK. DEX (Dalvik
EXecutable) - формат исполняемых файлов для виртуальной машины Dalvik,
оптимизированный для использования минимального объема памяти. При
использовании IDE Eclipse и плагина ADT (Android Development Tools)
компиляция классов Java в формат .dex происходит автоматически.
Архитектура Android Runtime такова, что работа программ
осуществляется строго в рамках окружения виртуальной машины, что
позволяет защитить ядро ОС от возможного вреда со стороны других ее
составляющих. Поэтому код с ошибками или вредоносное ПО не смогут
испортить Android и устройство на его базе, когда сработают.
На еще более высоком уровне располагается каркас приложений
(Application Framework), архитектура которого позволяет любому
приложению использовать уже реализованные возможности других
приложений, к которым разрешен доступ. В состав каркаса входят следующие
компоненты:

- богатый и расширяемый набор представлений (Views), который может
быть использован для создания визуальных компонентов приложений,
например, списков, текстовых полей, таблиц, кнопок или даже встроенного
web-браузера;
- контент-провайдеры (Content Providers), управляющие данными,
которые одни приложения открывают для других, чтобы те могли их
использовать для своей работы;
- менеджер ресурсов (Resource Manager), обеспечивающий доступ к
ресурсам без функциональности (не несущим кода), например, к строковым
данным, графике, файлам и другим;


- менеджер оповещений (Notification Manager), позволяющий
приложениям отображать собственные уведомления для пользователя в
строке состояния;
- менеджер действий (Activity Manager), управляющий жизненными
циклами приложений, сохраняющий историю работы с действиями,
предоставляющий систему навигации по действиям;
- менеджер местоположения (Location Manager), позволяющий
приложениям периодически получать обновленные данные о текущем
географическом положении устройства.
Application Framework предоставляет в распоряжение приложений в ОС
Android вспомогательный функционал, благодаря чему реализуется принцип
многократного использования компонентов приложений и ОС. Естественно, в
рамках политики безопасности.
И, наконец, самый высокий, самый близкий к пользователю уровень
приложений. Именно на этом уровне пользователь взаимодействует со своим
устройством, управляемым ОС Android. Здесь представлен набор базовых
приложений, который предустановлен на ОС Android. Например, браузер,
почтовый клиент, программа для отправки SMS, карты, календарь, менеджер
контактов и др. Список интегрированных приложений может меняться в
зависимости от модели устройства и версии Android. К этому уровню также
относятся все пользовательские приложения.
Разработчик обычно взаимодействует с двумя верхними уровнями
архитектуры Android для создания новых приложений. Библиотеки, система
исполнения и ядро Linux скрыты за каркасом приложений.
Повторное использование компонентов других приложений приводит к
идее задач в Android. Приложение может использовать компоненты другого
Android приложения для решения задачи, например, если разрабатываемое
приложение предполагает использование фотографий, оно может вызвать
приложение, управляющее фотографиями и зарегистрированное в системе
Android, выбрать с его помощью фотографию и работать с ней.


Для пополнения коллекции приложений своего мобильного устройства
пользователь может воспользоваться приложением Google Play, которое
позволяет покупать и устанавливать приложения с сервиса Google Play.
Разработчики, в свою очередь, могут выкладывать свои приложения в этот
сервис, Google Play отслеживает появление обновлений приложения,
сообщает пользователям этого приложения об обновлении и предлагает
установить его. Также Google Play предоставляет разработчикам доступ к
услугам и библиотекам, например, доступ к использованию и отображению
Google Maps.
Для установки приложения на устройствах с ОС Android создается файл
с расширением *.apk (Android package), который содержит исполняемые
файлы, а также вспомогательные компоненты, например, файлы с данными и
файлы ресурсов. После установки на устройство каждое приложение "живет"
в своем собственном изолированном экземпляре виртуальной машины Dalvik.


## 1

## ЛЕКЦИЯ 2. НАТИВНЫЕ ПРИЛОЖЕНИЯ, ВЕБ - ПРИЛОЖЕНИЯ,

## ГИБРИДНЫЕ И КРОССПЛАТФОРМЕННЫЕ ПРИЛОЖЕНИЯ, ИХ

## ОБЛАСТИ ПРИМЕНЕНИЯ

Компании, которые думают о разработке приложения (для своих
клиентов или внутреннего пользования) могут выбрать один из трех вариантов
мобильных приложений — нативные, веб или гибридные. Давайте
проанализируем каждый тип, рассмотрим преимущества и недостатки, и
определимся, какой из них будет лучшим выбором в той или иной ситуации и
лучше всего удовлетворит потребности при создании мобильного
приложения.

**Нативные приложения**
Под нативным мы подразумеваем **мобильное приложение** , которое
создается для определенной платформы и непосредственно устанавливается
на устройство пользователя (занимая определенный объем памяти). Такие
приложения пользователь загружает через магазин приложений той или иной
платформы, такой как Play Store для Google и Apple App Store для iOS.
С нативными приложениями компании могут изготовить приложение
согласно индивидуальным запросам, чтобы затем пользователю было удобно
им пользоваться, в дополнение к веб-сайту или другому каналу, которым он
уже привык пользоваться. Эта целостность и является существенным
преимуществом нативных приложений.
Некоторые другие важные преимущества нативных приложений:

- Обозначение геолокации позволяет компаниям подстраивать свои
программы лояльности или промоакции. Потребители могут получать
уведомления, когда они находятся возле физических магазинов, или имеют
возможность получить региональную скидку.


## 2

- Данные действий (или бездействия) пользователя могут быть легко
собраны и проанализированы, таким образом облегчая оценку эффективности
всего приложения либо его отдельных функций.
- **Нативные приложения** , как правило, работают и «чувствуются»
лучше. Веб-приложения иногда создаются для имитации нативных, но они
ограничиваются скоростью интернета и возможностями дизайна.
И возможные недостатки:
- Нативные приложения зачастую более дорогие в разработке, особенно
для компаний, которым нужны приложения на кроссплатформенных ОС
- Нативные приложения должны быть одобрены каждым магазином
приложений, а процесс привлечения внимания к нему пользователей может
быть сложным (если это не приложение для внутреннего пользования в
компании)

**Веб** - **приложения**
Как вы уже могли догадаться, эти приложения работают через веб-
браузер на устройстве пользователя. Эти приложения по сути являются
индивидуализированными вебсайтами, которые сделаны таким образом,
чтобы выглядеть и использоваться как нативные приложения, но на самом
деле они не находятся на устройстве пользователя. Их можно сравнить с
облачным хранилищем в сравнении с данными, которые хранятся на жестком
диске компьютера. При хорошей, качественной разработке, которая включает
в себя подбор размеров и прокрутку, веб-приложения часто работают подобно
нативным приложениям.
Вот некоторые ключевые преимущества веб-приложений:

- Приложения на веб-основе легче поддерживаются и они могут
функционировать на платформе с любой ОС
- Разработчики могут предлагать приложения без необходимости их
утверждения какими-либо магазинами приложений


## 3

- Более быстрая разработка циклов с использованием CSS, HTML и
JavaScript
И несколько минусов:
- У веб-приложений нет доступа к устройству пользователя. Несмотря
на то, что иногда было бы удобно, это ограничивает многие функции, которые
используются в нативных приложениях для более персонализированного
использования
- Пользователи должны использовать их через сеть, что значительно
снижает контроль безопасности
- Поиск приложения может быть затруднительным, так как не
существует магазина приложений с каталогом и функцией поиска в нем.

**Гибридные приложения**
Гибридные приложения являются чем-то средним между нативными и
веб-приложениями. Фактически они создаются так, чтобы выглядеть и
использоваться как нативные приложения. Их также устанавливают на
телефон пользователя и их можно найти в магазинах приложений. Различие
заключается в том, что они обязательно должны размещаться в рамках
нативного приложения и созданы, чтобы работать через WebView, и таким
образом они могут получать доступ к информации на устройстве пользователя
для больших возможностей.
Дополнительные преимущества гибридных приложений:

- Гибридные приложения обладают наибольшей функциональностью и
персонализацией для пользователя
- Разработчики не ограничены одной платформой, вместо этого они
могут создать гибридное приложение, которое будет работать с несколькими
платформами (в случае работы как нативное приложение)
- Гибриды — хорошая опция для разработчиков, которые создают
визуально насыщенные приложения, например, игры (которые не будут
хорошо работать в виде веб-приложений)


## 4

В любом случае, есть некоторые недостатки, о которых стоит подумать
при выборе гибридного приложения:

- Слишком сложные приложения лучше всего делать нативными
- Разработка требует дополнительных времени и усилий (по сравнению
с веб-приложениями), чтобы такое приложение выглядело и ощущалось
пользователем как нативное
- Магазины приложений могут отклонять гибридные приложения,
которые работают недостаточно плавно
Выбор подходящей модели **мобильного приложения** — это очень
важный этап в его разработке, на который влияют несколько факторов, таких
как техническая оценка разработчиков; потребность в доступе к информации
на устройстве; влияние скорости интернета на приложение; одно- или
многоплатформенное ли приложение.
Кроссплатформенные приложения против нативных: сравнение и выбор
подходов

```
Рисунок 1. Время приложений
```

## 5

Как правило, выход любого бизнеса в интернет протекает
по следующему сценарию: сначала компания запускает сайт, затем его
адаптируют под мобильные устройства, и если наблюдается прирост трафика,
появляется смысл закрепиться среди владельцев мобильных гаджетов,
и компания выпускает приложение.
Сравнивать мобильный сайт и приложение нет смысла — второе
однозначно выигрывает за счет широты своих возможностей и отзывчивого
интерфейса, взаимодействовать с которым через телефон или планшет гораздо
комфортнее. Кроме того, приложение может работать без постоянного
подключения к интернету.
Вне зависимости от того, на чем построен ваш бизнес — на продажах,
предоставлении услуг или просветительской деятельности, сегодня
невозможно не учитывать время, которое люди проводят перед экранами
мобильных устройств.
Эта статья призвана рассказать о двух подходах к разработке
приложений — нативном и кроссплатформенном.
Каждый из подходов обладает своей спецификой, критически влияющей
на конечный результат. И дабы облегчить понимание между заказчиком
и разработчиком, хочется рассказать о том, что собой представляют оба
подхода, разобрать их достоинства и недостатки, разрушить укрепившиеся
стереотипы о разработке и дать ответ на главный вопрос: как сделать выбор
в пользу того или иного подхода по принципу целесообразности.

**Нативный подход
Нативные приложения** — это приложения, с которыми
вы сталкиваетесь с первого дня использования устройства. Это установленные
по умолчанию браузер, почтовый клиент, адресная книга, будильник,
календарь и другие стандартные программы.
Как создать нативное приложение? Если разработчики в процессе
написания приложения пользуются принятым для конкретной платформы


## 6

языком программирования, будь то Objective-C и Swift для iOS или Java для
Android, такое приложение будет называться нативным (от англ. native —
родной, естественный). «Нативки» могут получать доступ ко всем службам,
сервисам и примочкам телефона: камере, микрофону, геолокатору,
акселерометру, календарю, медиафайлам, уведомлениям и так далее —
в общем, полноценно обживаются и чувствуют себя как дома.

**Кроссплатформенный подход
Кроссплатформенные приложения** — что это? Представьте себе
мобильный сайт, которому не всегда нужен интернет, а с точки зрения
дизайна он ближе к мобильным приложениям, а не к веб-страницам.
Примерно так можно описать кроссплатформенные приложения.
Так на чём писать кроссплатформенные приложения? Зачастую они
создаются на языке разметки и стилей (HTML, CSS и JavaScript), как
и мобильные сайты. Логически такой поступок оправдывается тем, что,
в конце концов, весь интернет-контент — это HTML-страницы. Такие
приложения пишутся одновременно для всех платформ и адаптированы
к большинству устройств, потому что для их работы в основном используется
браузерный движок.
Большинство специалистов, создающих такие приложения, пользуются
фреймворком PhoneGap. Его особенность заключается в том, что он позволяет
открыть приложению доступ к аппаратным и программным возможностям
платформы. Также к технологиям разработки кроссплатформенных
приложений относятся Xamarin, Unity и прочие, но они не так популярны,
как веб-технологии.
Компания Лайв Тайпинг имеет опыт разработки кроссплатформенных
приложений. При создании таких проектов, как Classboom и «Карьера
в кармане» мы успешно использовали фреймворк PhoneGap. Ниже — цитата
из нашей краткой характеристики технологии для сайта Clutch.


## 7

«PhoneGap помог нам создать надёжно работающие
кроссплатформенные приложения для iOS и Android. Кроме того,
использование PhoneGap снизило время разработки, что повлияло
на стоимость приложения для клиента."
Владислав Коробов, исполнительный директор Live Typing.

**Гибридные приложения**
Как видно, планка для входа в более чем перспективную область
разработки мобильных приложений значительно снизилась. Кто-то может
подумать, что теперь верстальщики, которые не идут дальше проверенных
HTML и CSS, будут отнимать хлеб у настоящих программистов. Другие видят
за кроссплатформенным подходом будущее, в котором время и затраты
на разработку приложений будут полностью оптимизированы. С обеих сторон
найдутся аргументы, объясняющие, почему правильным является именно
этот, а не другой подход к разработке.
Но когда мы говорим о решении определённых задач, эффективнее
будет эти подходы скомбинировать — использовать кроссплатформенные
преимущества HTML для оформления контента, а требовательные к скорости
отзывчивости меню и элементы управления сделать нативными, затратив
на это минимум усилий, времени и бюджета. Такие приложения называются
**гибридными**. В этом случае только объём нативного кода определяет, какому
подходу больше соответствует разработка приложения.
Какие ситуации приводят к слиянию подходов? Предположим, что
клиенту нужна незатейливая новостная лента, где не будет ничего, кроме
текста и изображений. Исходя из этой задачи, разработчик принимает
решение использовать кроссплатформенный подход. Но если через некоторое
время заказчик пожелает, чтобы приложение хранило большое количество
данных или обрабатывало звук и графику, задача усложняется. Для этих целей
нужно писать нативный код под каждую конкретную платформу, и некогда
полностью кроссплатформенное приложение превращается в гибридное.


## 8

Распространено заблуждение, что за любой иконкой на рабочем столе
пользователя ждёт нативное приложение. Это заблуждение пустило корни
настолько глубоко, что даже в профессиональных кругах грешат
формулировками высокого градуса абсурдности вроде «нативное фонгэп-
приложение». Но на рабочий стол можно вывести даже ярлык для сайта,
поэтому иконка ничего не гарантирует, и по ту сторону с равной
вероятностью может оказаться как нативное приложение, так и любое другое.

**Сравнение подходов**
Рынок предложений растёт. Статистика продаж мобильных приложений
показывает, что год от года пользователи гаджетов всё чаще меняют
стандартные сервисы на альтернативные. Так, родной менеджер задач
заменяется на Wunderlist, почтовый клиент — на приложение Mailbox,
Evernote оказывается предпочтительнее стандартных заметок.
Заказчику важно знать преимущества и недостатки каждого из подходов
и не завышать ожидания, делая выбор. Проводить сравнительный анализ
будет уместно по ряду критериев.

**Зависимость от платформы**
Могло сложиться впечатление, что кроссплатформенному приложению
комфортно на всех платформах, вплоть до самых непопулярных. Требуется
оговорка: чтобы это убеждение соответствовало действительности, под
каждую платформу, возможно, придётся писать кусок дополнительного кода.
В случае же нативных приложений можно рассчитывать на их отличную
работу, но для каждой платформы требуется разрабатывать свою версию.

**Дизайн интерфейса**
Не затронуть гайдлайны в контексте разработки мобильных
приложений невозможно. Гайдлайны — это ценные указания от компаний-
производителей платформ в адрес разработчиков мобильных приложений,


## 9

направленные на то, чтобы подогнать их дизайн и функциональность под
стандарты. Гайдлайны — это фундамент, на котором зиждется психология
и комфорт пользователей платформы. Проще говоря, элементы интерфейса
имеют привычный внешний вид и расположение.
Языковая среда, в которой разрабатываются нативные мобильные
приложения, обладает необхоимыми инструментами для создания
привычного пользователю интерфейса. Другая ситуация с веб-технологиями:
чтобы сделать кроссплатформенное приложение похожим на нативное,
придётся приложить немало усилий. Разные кроссплатформенные
фреймворки (Framework 7, Sencha Touch, Kendo UI, Ionic и другие) помогают
с той или иной степенью достоверности имитировать нативный интерфейс,
но чаще всего отзывчивость, скорость анимации, эффекты и дизайн будут
другими. Этому и посвящен следующий пункт.

**Пользовательский опыт**
Первое, чего на подсознательном уровне ждёт пользователь от своего
приложения — это отзывчивости. За действием пользователя тут же следует
ответная реакция, прокрутка страницы и анимация протекают плавно и без
подвисаний. Кроссплатформенные приложения в этом плане значительно
уступают нативным, а если не ходить вокруг да около, они тормозят, и это
их главная проблема.
Также пользователь уверен в том, что каждый элемент управления,
каждая иконка будут иметь стандартный вид и положение на экране
приложения. Для разных платформ эти стандарты будут разными, и если
создание кроссплатформенного приложения осуществлялось по гайдлайнам
iOS, то пользователям Android это доставит дискомфорт, и наоборот.
Одним из ярчайших примеров может стать кнопка Back: это типичная
для Android функция, которая не имеет аналога на iOS. Поэтому, когда
вы создаёте кроссплатформенное мобильное приложение, компромиссов
в этой ситуации может быть только два: либо дизайн един для обеих


## 10

платформ, и пользователи одной из них вынуждены приспосабливаться, либо
вы создаёте два разных дизайна с учётом особенностей каждой платформы.
По сути, во втором случае создаются два приложения, но на одном
кроссплатформенном языке.

**Ограничения**
Нативное приложение, написанное под конкретную платформу,
чувствует себя её полноправным обитателем, получая максимальный доступ
ко всем устройствам и сервисам устройства. Проектируя кроссплатформенное
приложение, разработчик учитывает только возможности фреймворка,
налагающего свои ограничения.
Может создать проблему и то, что у фреймворков есть множество
версий, и чем старее версия, тем больше ограничений. В любом случае,
кроссплатформенному приложению открыты двери далеко не ко всем фишкам
платформы. Не всегда возникает необходимость в полной интеграции — её
глубина зависит от задач, которые должно решать приложение.

**Безопасность**
Для всех популярных браузеров существует стандартный безопасный
протокол передачи данных — HTTPS. Но если требуется особый уровень
шифрования, решение этой проблемы ложится на разработчика. Обеспечение
надёжной защиты данных возможно только при нативной разработке
мобильных приложений, так как связано с математикой, а подобные операции
требуют максимально эффективного использования аппаратных ресурсов.

**Обслуживание и поддержка**
Комплексное обслуживание нативных Android и iOS-
приложений (поиск и исправление ошибок, обновление и любое
незначительное изменение) в среднем занимает в два раза больше ресурсов
по причине необходимости как минимум двух разных специалистов (iOS


## 11

и Android). С кроссплатформенным приложением может управляться один
разработчик.
Стоимость мобильной разработки и затрачиваемом времени опутана
заблуждениями и мифами, а потому хотелось бы затронуть эти вопросы
отдельно и если не расставить все точки над i, то хотя бы этому
поспособствовать.
**Быстрая и дешёвая разработка кроссплатформенных
приложений — миф или реальность**
Кроссплатформенная разработка мобильных приложений обходится
дешевле, что объясняется меньшими объёмами работ относительно нативной
разработки. Но и здесь есть свои подводные камни, разглядеть которые
можно, только поняв принципы ценообразования.
Всегда нужно помнить, что время и стоимость регулируется
сложностью и уровнем качества выполнения задачи. Допустим, что для
разработки кроссплатформенного продукта у нас есть один специалист,
который знает HTML, CSS, JavaScript и имеет опыт работы в PhoneGap. Один
специалист — это одна абстрактная единица ресурса (допустим,
один человеко-месяц).
Для работы над нативным приложением таких ресурсов требуется два —
iOS и Android. В итоге, для завершения нативного проекта требуется
два человеко-месяца, для завершения кроссплатформенного — полтора.
Справедливым будет вопрос: «Как так — полтора? Почему не один?»
Увы, на практике кроссплатформенное приложение, хорошо работающее
на iOS, будет плохо работать на Android — у всех браузерных движков своя
специфика, и как следствие, оптимизацию под Android может уйти ещё
половина человеко-месяца.
Исходя из вышесказанного, был произведен расчёт стоимости
мобильной разработки в случае нативного и кроссплатформенного подходов,
представленный в двух таблицах. Результаты в таблице 1 отталкиваются
от средней почасовой ставки фрилансеров из баз freelansim.ru и fl.ru в рублях,


## 12

в таблице 2 — средней почасовой ставки фрилансеров и студий
из международной базы upwork.com в долларах.
Таблица 1

```
Платформа
```
```
Средняя
ставка
(RUR)
```
```
Количество человеко-
месяцев
```
```
Количество
часов
```
```
Итого,
RUR
iOS/Android 800 2 320 256000
Гибридные
приложения 800 1,5^240 192000
```
Таблица 2

```
Платформа
```
```
Средняя
ставка
(USD)
```
```
Количество человеко-
месяцев
```
```
Количество
часов
```
```
Итого,
USD
iOS/Android 25 2 320 8000
Гибридные
приложения 25 1,5^240 6000
```
Когда мы сравнивали подходы по нескольким критериям, мы сказали,
что степень интеграции приложения в платформу обусловлена сложностью
задачи, решаемой приложением. Использование того или иного шаблона или
готового решения может быть довольно дешевым способом сделать
приложение, пока возможностей шаблона или решения достаточно для
выполнения конкретной задачи.

**Но есть нюанс**
И он заключается в структурной особенности приложения. Чаще всего
оно предполагает наличие серверной части, куда пользователи приложения
сохраняют данные и через которую обмениваются ими с другими
пользователями, и она тоже требует финансовых вложений. Работа над ней
может занимать до трети всего времени разработки, и оно увеличивается при
необходимости создания административной панели для удобного управления
данными.


## 13

```
Резюме
К нативной разработке стоит прибегать, если:
```
- вашему приложению требуется свободный доступ ко всем ресурсам
и сервисам телефона;
- вы хотите получить максимально отзывчивое приложение;
- приложение должно уметь работать в офлайне;
- ваше приложение должно максимально эффективно использовать
аппаратные части устройства.
Ваш вариант — **кроссплатформенная** мобильная разработка, если:
- вы готовы примириться с низкой отзывчивостью;
- приложение не предполагает сложной анимации и не занимается
расчетами;
- приложению необходим постоянный доступ в интернет, чтобы
загружать контент;
- вам нужно быстро выйти на рынок для тестирования идеи;
- у вас есть сайт, и вы хотите обернуть его в приложение
за минимальную цену.
К выбору той или иной стратегии всегда приводят индивидуальные
обстоятельства, ни одна статья не даёт универсального ответа.
Наш материал скорее дает вводную информацию общего характера,
помочь заказчику и разработчику наладить диалог на понятном для обоих
языке.
Окончательное решение стоит принимать после консультаций
с разработчиками. Чем больше аргументов относительно того или иного
подхода вы выслушаете, тем лучше.


## 1

## ЛЕКЦИЯ 3. ВВЕДЕНИЕ. УСТАНОВКА ANDROID STUDIO И

## ANDROID SDK

Бурное развитие информационных технологий в последнее время
привело к тому, что появилось много новых устройств и технологий, таких,
как планшеты, смартфоны, нетбуки, другие гаджеты. Они все более прочно
входят в нашу жизнь и становятся привычным делом. Лидирующей
платформой среди подобных гаджетов на сегодняшний день является ОС
Андроид.
Android используется на самых разных устройствах. Это и смартфоны, и
планшеты, и телевизоры, и смарт-часы и ряд других гаджетов. По разным
подсчетам за 2020 год этой операционой системой пользуются около 85%
владельцев смартфонов, а общее количество пользователей сматрфонов на ОС
Android оценивается в более чем 2,5 млрд. человек по всему миру.
ОС Андроид была создана разработчиком Энди Рубином (Andy Rubin) в
качестве операционной системы для мобильных телефонов и поначалу
развивалась в рамках компании Android Inc. Но в 2005 году Google покупает
Android Inc. и начинает развивать операционную систему с новой силой.
Android постоянно эволюционирует, и вместе с операционной системой
эволюционируют средства и инструменты для разработки. На данный момент
(ноябрь 2020 года) последней версией является Android 11.0, которая вышла в
сентябре 2020 года:
**Версия Кодовое имя Дата выпуска Уровень API**
11.0 11 8 сентября 2020 30
10.0 10 3 сентября 2019 29
9.0 Pie 6 августа 2018 28
8.1 Oreo 5 декабря 2017 27
8.0 Oreo 21 августа 2017 26
7.1 Nougat 4 октября 2016 25


## 2

```
Версия Кодовое имя Дата выпуска Уровень API
7.0 Nougat 22 августа 2016 24
6.0 Marshmallow 5 октября 2015 23
5.1 Lollipop 9 марта 2015 22
5.0 Lollipop 3 ноября 2014 21
4.4 KitKat 31 октября 2013 19
4.3 Jelly Bean 24 июля 2013 18
4.2 Jelly Bean 13 ноября 2012 17
4.1 Jelly Bean 9 июля 2012 16
4.0 Ice Cream Sandwich 16 декабря 2011 15
2.3 Gingerbread 6 декабря 2010 10
```
**Что нужно для разработки?**
Стоит отметить, что разрабатывать приложения под Android можно с
помощью различных фреймворков и языков программирования. Так, в
качестве языков программирования могут применяться Java, Kotlin, Dart
(фреймворк Flutter), C++, Python, C# (платформа Xamarin) и т.д. В данном
руководстве мы будем использовать именно язык Java, как наиболее
распространенный и используемый. Поэтому прежде чем приступать к
освоению программирования под Android по данному руководству,
необходимо освоить хотя бы базовые момент языка Java.

**Установка средств разработки**
Существуют разные среды разработки для Android. Рекомендуемой
средой разработки является Android Studio, которая создана специально для
разработки под ОС Android. Поэтому мы ее и будем использовать. Загрузить
файл установщика можно с официального сайта:
https://developer.android.com/studio:


## 3

Кроме самой среды Android Studio для разработки также потребуется
набор инструментов, который называется Android SDK. Например, если ранее
Android SDK еще не было установлено, то при первом обращении к Android
Studio она сообщит, что Android SDK отсутствует.


## 4

Мы можем отдельно вручную загрузить Android SDK с официального
сайта и установить его. Либо мы можем сделать это непосредственно из
Android Studio. Так, нажмем на кнопку Next. И на следующем экране нам
будет предложено загрузить Android SDK для последней версии API (в данном
случае для Android 11):


## 5

Здесь же мы можем указать место для установки Android SDK, если путь
по умолчанию нас не устраивает.
Нажмем на кнопку Next, и далее нам отобразится окно со сводкой того,
что именно будет установлено:


## 6

```
Нажмем на кнопку Finish, чтобы, наконец, все это установить.
```
И после завершения установки нажмем на кнопку Finish. И мы можем
приступать к созданию приложений.


## 7

**Первый проект в Android Studio**
Теперь создадим первое приложение в среде Android Studio для
операционной системы Android. Откроем Android Studio и на начальном
экране выберем пункт Create New Project:

При создании проекта Android Studio вначале предложит нам выбрать
шаблон проекта:


## 8

Android Studio предоставляет ряд шаблонов для различных ситуаций, но
самыми распространенными являются Basic Activity и Empty Activity. Это
самые удобные шаблоны для старта для создания большинства приложений.
И по умолчанию выбран шаблон Empty Activity (если он не выбран, выберем
его) и нажмем на кнопку Next.
После этого отобразится окно настроек нового проекта:


## 9

В окне создания нового проекта мы можем установить его начальные
настройки:
В поле Name вводится название приложения. Укажем в качестве имени
название HelloApp
В поле Package Name указывается имя пакета, где будет размещаться
главный класс приложения. В данном случае для тестовых проектов это
значение не играет большого значения, поэтому
установим com.example.helloapp.
В поле Save Location устанавливается расположение файлов проекта на
жестком диске. Можно оставить значение по умолчанию.


## 10

В поле Language в качестве языка программирования
укажем Java (будьте внимательны, так как по умолчанию в этом поле стоит
Kotlin)
В поле Minimum SDK указывается самая минимальная поддерживаемая
версия SDK. Оставим значение по умолчанию - API 21: Android 5.0
(Lollipop), которая означает, что наше приложение можно будет запустить
начиная с Android 5.0, а это 94% устройств. На более старых устройствах
запустить будет нельзя.
Стоит учитывать, что чем выше версия SDK, тем меньше диапазон
поддерживаемых устройств.
Далее нажмем на кнопку Finish, и Android Studio создаст новый проект:

В начале вкратце рассмотрим структуру проекта, что он уже имеет по
умолчанию:


## 11

Проект Android может состоять из различных модулей. По умолчанию,
когда мы создаем проект, создается один модуль - app. Модуль имеет три
подпапки:
manifests: хранит файл манифеста AndroidManifest.xml, который
описывает конфигурацию приложения и определяет каждый из компонентов
данного приложения.
java: хранит файлы кода на языке java, которые структурированы по
отдельным пакетам. Так, в папке com.android.helloapp (название которого
было указано на этапе создания проекта) имеется по умолчанию
файл MainActivity.java с кодом на языке Java, который представляет класс
MainActivity, запускаемый по умолчанию при старте приложения


## 12

res: содержит используемые в приложении ресурсы. Все ресурсы
разбиты на подпапки.
папка drawable предназначена для хранения изображений,
используемых в приложении
папка layout предназначена для хранения файлов, определяющих
графический интерфейс. По умолчанию здесь есть файл activity_main.xml,
который определяет интерфейс для класса MainActivity в виде xml
папки mipmap содержат файлы изображений, которые предназначены
для создания иконки приложения при различных разрешениях экрана.
папка values хранит различные xml-файлы, содержащие коллекции
ресурсов - различных данных, которые применяются в приложении. По
умолчанию здесь есть два файла и одна папка:
файл colors.xml хранит описание цветов, используемых в приложении
файл strings.xml содержит строковые ресурсы, используемые в
приложении
папки themes хранит две темы приложения - для светлую (дневную) и
темную (ночную)
Отдельный элемент Gradle Scripts содержит ряд скриптов, которые
используются при построении приложения.
Во всей этой структуре следует выделить файл MainActivity.java,
который открыт в Android Studio и который содержит логику приложения и
собственно с него начинается выполнение приложения. И также выделим
файл activity_main.xml, который определяет графический интерфейс - по сути
то, что увидит пользователь на своем смартфоне после загрузки приложения.

**Запуск проекта**
Стандартный проект, который был создан в прошлой теме, который уже
содержит некоторый примитивный функционал. Правда, этот функционал
почти ничего не делает, только выводит на экран строку "Hello world!".


## 13

Для запуска и тестирования приложения мы можем использовать
эмуляторы или реальные устройства. Но в идеале лучше тестировать на
реальных устройствах. К тому же эмуляторы требуют больших аппаратных
ресурсов, и не каждый компьютер может потянуть требования эмуляторов. А
для использования мобильного устройства для тестирования может
потребоваться разве что установить необходимый драйвер.

**Режим разработчика на телефоне**
По умолчанию опции разработчика на смартфонах скрыты. Чтобы
сделать их доступными, надо зайти в **Settings > About phone (Настройки > О
телефоне)** (в Android 8 это в Settings > System > About ph **one (Настройки >
Система > О телефоне)** ) и семь раз нажать **Build Number (Номер сборки)**.

Вернитесь к предыдущему экрану и там вы увидите доступный
пункт **Developer options (Для разработчика)**.


## 14

Перейдем к пункту **Для разработчиков** и включим возможность
отладки по USB:


## 15

**Запуск приложения**
Подключим устройство с ОС Android (если мы тестируем на реальном
устройстве) и запустим проект, нажав на зеленую стрелочку на панели
инструментов.

Выберем устройство и нажмем на кнопку OK. И после запуска мы
увидим наше приложение на экране устройства:


## 16

**Создание графического интерфейса**
Ранее мы рассмотрели создание простого приложения, который
предлагает Android Studio по умолчанию и которое просто выводит на экран
строку Hello Android.

Но почему у нас выводится именно эта строка? Почему у нас вообще
создается именно такой визуальный интерфейс?
Выполнение приложения Android по умолчанию начинается с
класса MainActivity, который по умолчанию открыт в Android Studio:


## 17

Каждый отдельный экран или страница в приложении описывается
таким понятием как activity. В литературе могут использоваться различные
термины: экран, страница, активность. В данном случае я буду использовать
понятие "activity". Так вот, если мы запустим приложение на устройстве, то на
экране мы по сути увидим определенную activity, которая предсталяет данный
интерфейс.
Класс MainActivity, по сути, представляет обычный класс java, в начале
которого идет определение пакета данного класса:

Далее идет импорт классов из других пакетов, функциональность
которых используется в MainActivity:

```
Затем идет собственно определение класса:
```
По умолчанию MainActivity наследуется от класса AppCompatActivity,
который выше подключен с помощью директивы импорта.
Класс AppCompatActivity по сути представляет отдельный экран (страницу)
приложения или его визуальный интерфейс. И MainActivity наследует весь
этот функционал.


## 18

По умолчанию MainActivity содержит только один метод onCreate(), в
котором фактически и создается весь интерфейс приложения:

В метод setContentView() передается ресурс разметки графического
интерфейса:

Именно здесь и решается, какой именно визуальный интерфейс будет
иметь MainActivity. Но что в данном случае представляет
ресурс R.layout.activity_main? Это файл activity_main.xml из
папки res/layout (в принципе можно заметить, что название ресурса
соответствует названию файла), который также по умолчанию открыт в
Android Studio:

```
Файл activity_main.xml
```

## 19

Android Studio позволяет работать с визуальным интерфейсом как в
режиме кода, так и в графическом режиме. Так, по умолчанию файл открыт в
графическом режиме, и мы наглядно можем увидеть, как у нас примерно будет
выглядеть экран приложения. И даже набрасать с панели инструментов какие-
нибудь элементы управления, например, кнопки или текстовые поля.
Но также мы можем работать с файлом в режиме кода,
поскольку activity_main.xml — это обычный текстовый файл с разметкой xml.
Для переключения к коду нажмем на кнопку Code над графическим
представлением. (Дополнительно с помощью кнопки Split можно
переключиться на комбинированное представление код + графический
дизайнер):

Здесь мы увидим, что на уровне кода файл activity_main.xml содержит
следующую разметку:


## 20

Весь интерфейс представлен элементом-
контейнером androidx.constraintlayout.widget.ConstraintLayout:

ConstraintLayout позволяет расположить вложенные элементы в
определенных местах экрана. Вначале элемента ConstraintLayout идет
определение пространств имен XML:

Каждое пространство имен задается следующим
образом: xmlns:префикс="название_ресурса". Например, в


## 21

```
Название ресурса (или URI - Uniform Resource Indicator)
```
- "http://schemas.android.com/apk/res/android". И этот ресурс сопоставляется с
префиксом android (xmlns:android).
    Зачем эти пространства имен нужны? Каждый ресурс или URI
определяет некоторую функциональность, которая используется в
приложении, например, предоставляют теги и атрибуты, которые
необходимые для построения приложения.
    xmlns:android="http://schemas.android.com/apk/res/android": содержит
основные атрибуты, которые предоставляются платформой Android,
применяются в элементах управления и определяют их визуальные свойства
(например, размер, позиционирование)
    xmlns:app="http://schemas.android.com/apk/res-auto": содержит атрибуты,
которые определены в рамках приложения
    xmlns:tools="http://schemas.android.com/tools": применяется для работы с
режиме дизайнера в Android Studio
    И чтобы упростить работу с этими ресурсами, применяются префиксы.
Например, дальше мы видим:

android:layout_width определяет ширину контейнера. Этот атрибут
(layout_width) расположен в ресурсе
"http://schemas.android.com/apk/res/android". И поскольку этот ресурс
сопоставляется с префиксом android, то для обращения к атрибуту перед ним
через двоеточие указывается префикс данного ресурса.
Значением атрибута android:layout_weight является "match_parent".
Это значит, что элемент (ConstraintLayout) будет растягиваться по всей
ширине контейнера (экрана устройства).


## 22

Атрибут android:layout_height="match_parent" определяет высоту
контейнера и также определен в "http://schemas.android.com/apk/res/android".
Значение "match_parent" указывает, что ConstraintLayout будет растягивается
по всей длине контейнера (экрана устройства).
Атрибут tools:context определяет, какой класс activity (экрана
приложения) связан с текущим определением интерфейса. В данном случае
это класс MainActivity. Это позволяет использовать в Android Studio
различные возможности в режиме дизайнера, которые зависят от класса
activity.

TextView
Текстовое поле устанавливает текст с помощью атрибута android:text.

android:layout_width устанавливает ширину виджета.
Значение wrap_content задает для виджета величину, достаточную для
отображения в контейнере.
android:layout_height устанавливает высоту виджета.
Значение wrap_content аналогично установке ширины задает для виджета
высоту, достаточную для отображения в контейнере
android:text устанавливает текст, который будет выводиться в TextView
(в данном случае это строка "Hello World!")
app:layout_constraintLeft_toLeftOf="parent": указывает, что левая
граница элемента будет выравниваться по левой стороне контейнера
ConstraintLayout


## 23

Обратите внимание, что этот атрибут определен в пространстве имен с
префиксом app, то есть в "http://schemas.android.com/apk/res-auto".
app:layout_constraintTop_toTopOf="parent": указывает, что верхняя
граница элемента будет выравниваться по верхней стороне контейнера
ConstraintLayout
app:layout_constraintRight_toRightOf="parent": указывает, что правая
граница элемента будет выравниваться по правой стороне контейнера
ConstraintLayout
app:layout_constraintBottom_toBottomOf="parent": указывает, что
нижняя граница элемента будет выравниваться по нижней стороне контейнера
ConstraintLayout
Стоит отметить, что последние четыре атрибута вместе будут приводить
к расположению TextView по центру экрана.
Таким образом, при запуске приложения сначала запускается класс
MainActivity, который в качестве графического интерфейса устанавливает
разметку из файла activity_main.xml. И поскольку в этой разметке прописан
элемент TextView, который представляет некоторый текст, то мы и увидим его
текст на экране смартфона.


## 1

## ЛЕКЦИЯ 4. СОЗДАНИЕ ПЕРВОГО ПРИЛОЖЕНИЯ И ДОБАВЛЕНИЕ

## ACTIVITY

В прошлых темах мы создали первый проект, однако весь проект
состоял лишь из примитивного кода, добавляемого по умолчанию. Теперь
определим сами приложение, которое также также будет очень простое. Пусть
на одной странице приложения мы будем вводить некоторые данные и по
нажатию на кнопку будет происходить переход к другой странице
приложения, которая будет отображать ранее введенные данные.
Итак, возьмем ранее созданный проект (или создадим новый).

**Добавление новой Activity**
И по умолчанию у нас уже есть одна activity - класс MainActivity. Теперь
добавим еще одну. Для этого нажмем правой кнопкой мыши в структуре
проекта на папку, в котором находится класс MainActivity, и затем в контекстном меню
выберем New->Activity->Empty Activity:

```
После этого откроется диалоговое окно создания новой activity:
```

## 2

В этом окне в поле Activity Name введем MessageActivity. После этого
в поле Layout Name автоматически должно установиться activity_message
(если не устновилось, то введем в это поле activity_message). В
остальных полях оставим значения по умолчанию:
Package Name - должен иметь то же название, что и пакет, в котором
находится MainActivity
Source Language должен иметь значение Java
И затем нажмем Finish.
После этого в папке с MainActivity должен появиться файл с новой
activity - MessageActivity:


## 3

Кроме того, в каталоге res/layout должен появиться
файл activity_message.xml, который представляет описание графического
интерфейса для MessageActivity.
Вначале откроем файл activity_message.xml и изменим его код
следующим образом:


## 4

Определение интерфейса для MessageActivity содержит только элемент
TextView, который выводит некоторую строку на экран. Рассмотрим
установленные в нем атрибуты:
android:id="@+id/messageText" - TextView имеет идентификатор "messageText", через
который мы сможем обращаться к TextView в коде java. Символ @ указывает XML-парсеру
использовать оставшуюся часть строки атрибута как идентификатор. А знак + означает, что если
для элемента не определен id со значением messageText, то его следует определить.
android:layout_width="wrap_content" - ширина текстового поля будет такой, чтобы вместить
все его содержимое на экране
android:layout_height="wrap_content" - высота TextView будет такой, чтобы вместить все его
содержимое на экране
android:textSize="18sp" - высота текста в TextView составляет 18 единиц (для установки
высоты шрифта используется величина sp)
app:layout_constraintBottom_toBottomOf="parent" - нижний край TextView будет
выравниваться по нижней стороне контейнера ConstraintLayout
app:layout_constraintLeft_toLeftOf="parent" - левая граница TextView будет выравниваться
по левой стороне контейнера ConstraintLayout
app:layout_constraintRight_toRightOf="parent" - правый край TextView будет выравниваться
по правой стороне контейнера ConstraintLayout
app:layout_constraintTop_toTopOf="parent" - верхний край TextView будет выравниваться по
верхней стороне контейнера ConstraintLayout


## 5

**Получение данных**
Суть MessageActivity будет заключаться в том, что она будет получать
некое текстовое сообщение и выводить его на экран (формально в элемент
TextView, который был определен выше). Как мы можем получить в
MessageActivity (и в любой другой activity) некоторые данные, которые
переданы из другой activity?
Возьмем код класса MessageActivity. По умолчанию он выглядит так:

```
И изменим его следующим образом:
```

## 6

Также, как и в MainActivity (и в других activity), создание текущей
activity происходит в методе onCreate(). Все классы activity должны
реализовать метод onCreate, так как система вызывает его при создании новой
activity. Именно в этом методе задается компоновка нового объекта activity с
помощью метода setContentView и именно здесь происходит начальная
настройка компонентов.
Каждый объект Activity вызывается объектом Intent. Мы можем в коде
Java получить вызывающий объект Intent с помощью метода getIntent:

Но Intent нам важен не сам по себе, а потому что через него в эту activity
будут передаваться данные. Эти данные могут представлять различные типы,
но в здесь мы предполагаем, что в MainActivity будет передаваться строка. И для
получения строки у объекта Intent вызывается метод getStringExtra():


## 7

В метод передается ключ данных. То есть каждый элемент
передаваемых данных представлен в формате "ключ-значение". Через ключ
мы можем получить значение. И в данном случае ключом будет "message". А
значение по этому ключу попадет в переменную String message.
Получив переданные в MessageActivity данные, мы можем передать их
в TextView для вывода на экране устройства. Для этого вначале находим
виждет TextView по его id и затем вызываем его метод setText(), который
устанавливает выводимый в TextView текст:

Таким образом, MessageActivity получит переданное ей сообщение и
выведет его в TextView. Теперь рассмотрим, как вызвать эту activity из
MainActivity и как передать ей это сообщение.

**Запуск второй Activity**
В прошлой теме мы определили MessageActivity, которая получает извне
некоторые данные. Теперь определим в MainActivity код, который будет
запускать MessageActivity и передавать ей некоторые данные.

```
Определение интерфейса
Изменим файл activity_main.xml следующим образом:
```

## 8

Здесь мы добавили в ConstraintLayout два элемента: EditText (поле для
ввода текста) и Button (кнопка). Рассмотрим по отдельности, что они
представляют.
Для ввода текста, который будет передаваться в MessageActivity, добавлен
элемент EditText:


## 9

Итак, мы определили следующие атрибуты:
android:id: обеспечивает уникальный идентификатор виджета, по которому мы
можем ссылаться на объект
android:layout_width задает ширину элемента. В данном случае значение "0dp". В
реальности ширина будет устанавливаться контейнером ConstraintLayout на основании
дополнительных атрибутов, которые идут далее.
android:layout_height устанавливает высоту контейнера.
Значение wrap_content задает для виджета величину, достаточную для отображения в
контейнере
android:layout_marginStart: задает отступ от отступ от левой границы контейнера. В
данном случае 16 единиц
android:layout_marginTop: задает отступ от отступ от верхней границы контейнера.
В данном случае 16 единиц
android:hint: задает тест-подсказку в текстовом поле
app:layout_constraintRight_toLeftOf: указывает, что EditText располагается слева от
элемента, id которого указан в качестве значения. Так, в данном случае значение
"@+id/button" представляет идентификатор нашей кнопки. То есть правая сторона элемента
EditText будет выравниваться по левой границе элемента Button.
app:layout_constraintLeft_toLeftOf="parent": указывает, что левая граница элемента
будет проходить по левой стороне контейнера ConstraintLayout (с учетом выше
установленного отступа)
app:layout_constraintTop_toTopOf="parent": указывает, что верхняя граница элемента
будет проходить по верхней стороне контейнера ConstraintLayout (с учетом выше
установленного отступа)
Теперь рассмотрим код кнопки - элемента Button, которая будет
запускать MessageActivity:


## 10

Элемент Button применяет следующие атрибуты:
android:id: идентификатор кнопки - button.
android:layout_width - в качестве ширины кнопки устнавливается
значение wrap_content, поэтому кнопка будет иметь ту ширину, которая достаточна для
вывода ее текста.
android:layout_height - значение wrap_content задает для виджета величину,
достаточную для отображения текста
android:layout_marginStart: задает отступ от отступ от условной левой границы
элемента - в данном случае это правый край текстового поля EditText. В данном случае он
равен 16 единиц
android:layout_marginTop: задает отступ от отступ от верхней границы контейнера.
В данном случае 16 единиц
android:text: задает тест кнопки
android:onClick: устанавливает обработчик нажатия на кнопку. Значение
"sendMessage", присвоенное атрибуту, представляет собой имя метода, определенного в
классе связанной activity (в данном случае в MainActivity). То есть при нажатии на кнопку
будет вызываться метод sendMessage, который мы далее определим.
app:layout_constraintLeft_toRightOf="@+id/editText": устанавливает выравнивание
левой стороны элемента Button по правой границе EditText.
Значение ="@+id/editText" указывает, что нижняя граница кнопки будет выравниваться по
нижней границе элемента с id editText, то есть текстового поля.
app:layout_constraintTop_toTopOf="parent": указывает, что верхняя граница элемента
будет проходить по верхней стороне контейнера ConstraintLayout с учетом отступа
app:layout_constraintRight_toRightOf: указывает, что правая граница элемента будет
проходить по правой стороне контейнера ConstraintLayout


## 11

Если мы перейдем к режиму дизайнера, например, в разделенном
режиме (код + дизайнер), то мы увидим следующий макет:

**Обработка нажатия кнопки**
Итак, выще мы определили для кнопки обработку
нажатия: android:onClick="sendMessage". Мы предполагаем, что по нажатию на
кнопку будет срабатывать метод sendMessage, в котором будет запускаться
MessageActivity. Для добавления этого метода изменим код класса MainActivity:


## 12

Обработчик нажатия кнопки - метод sendMessage() должен принимать в
качестве параметра объект View, который представляет саму нажатую кнопку:

Далее для запуска второй activity необходим объект Intent.
Объект Intent представляет некоторую задачу приложения, которую надо
выполнить (например, запуск activity):

```
Конструктор этого объекта принимает два параметра:
```

## 13

Первый параметр представляет контекст - объект Context (ключевое
слово this употребляется здесь, так как класс MainActivity является
подклассом класса Context)
Вторым параметром идет класс компонента, которому мы передаем
объект Intent. В качестве него будет выступать объект класса MessageActivity,
который был добавлен в прошлой теме
Внутри метода sendMessage() используем метод findViewById, чтобы
получить элемент EditText и передать введенный в него текст в объект intent:

Затем полученный из текстового поля текст передается в запускаемую
activity:

Параметр "message" указывает на ключ передаваемых данных. То есть
мы можем в новую activity передать множество данных, и чтобы их можно было
разграничить, для них устанавливается ключ. Обращаю внимание, что здесь
данные передаются по тому же ключу, по которому в MessageActivity мы
получаем эти данные:

Для запуска activity нужно вызвать метод startActivity() и передать ему
в качестве параметра объект Intent:

После вызова этого метода система получит сигнал и запустит новый
объект Activity, определенный объектом Intent.
Теперь запустим проект и после запуска приложения мы увидим
текстовое поле с кнопкой, но после ввода текста и нажатия на кнопку будет
запущена новая activity - MessageActivity, которая отобразит ранее введенные
данные:


## 14


```
Лекция 6: Рекомендации по проектированию GUI под Android
```
```
6 .1 Рекомендации разработчиков. Android Guideline
```
Когда платформа Android только появилась, не было никаких
рекомендаций по разработке дизайна, поэтому все разработчики
проектировали внешний вид приложений по своему вкусу. Отсутствие
единого стиля сказалось на интерфейсах не лучшим образом, многие
программы были откровенно некрасивы и неудобны. Кроме того,
операционная система Android работает на устройствах с различными
экранами, и разработчику необходимо помнить, что его приложение должно
масштабироваться под различные параметры смартфонов и планшетов.
В настоящее время существует стандарт Android Design, и, если вы
хотите, чтобы ваше приложение стало по-настоящему популярным и нужным,
настоятельно рекомендуем его придерживаться. Далее мы рассмотрим
основные принципы дизайна. Разумеется, в рамках этого курса невозможно
учесть все нюансы. В списке источников есть ссылка на рекомендации от
Android User Experience Team, к сожалению, все на английском языке.
Приведем выдержки из рекомендаций по дизайну:

- Реальные объекты гораздо веселее, чем кнопки и меню. Позвольте
людям манипулировать знакомыми вещами! Тогда работа будет эффективнее.
- Картинки работают быстрее, чем слова.
- Используйте короткие фразы, состоящие из простых слов. Люди часто
пропускают предложения, если они слишком длинные.
- Никогда не теряйте пользовательскую информацию. Если человеку
придется вводить данные повторно, велика вероятность того, что он откажется
использовать ваше приложение.
- Если объекты похожи, они должны выполнять сходные действия.
- Показывайте только то, что необходимо пользователю именно в этот
момент.


- Выводите пользователю сообщения, только если вопрос действительно
важен.
- Делайте важные вещи быстро.
- Разбивайте сложные задачи на несколько простых шагов.
- Будьте вежливы и корректны в общении с пользователем.
- Пользователь всегда должен быть уверен в том, что он знает, где сейчас
находится. На любом шаге он должен иметь возможность вернуться назад,
даже если это прервет выполнение какой-то задачи.
- Используйте интерфейсные элементы, которые будут работать в любой
ситуации.
- Самый главный принцип - НЕ УСЛОЖНЯЙТЕ пользователю жизнь!

```
6 .2 Обзор интерфейса
```
Приведем выдержки из рекомендаций по дизайну приложений для
Android. Сделаем краткий обзор интерфейса операционной системы.
Домашний экран - это настраиваемая пользователем область, которая
может содержать иконки приложений, папки и виджеты. Смартфон может
иметь несколько домашних экранов, навигация между ними осуществляется с
помощью перелистывания влево или вправо.
На домашнем экране в центре нижней части есть кнопка для открытия
экрана приложений. Экран приложений позволяет пользователю запустить
любую из установленных программ. Если устройство было использовано для
отладки в процессе разработки, то приложение тоже окажется в этом списке и
его можно будет вызвать даже после отключения от компьютера. Если
приложение было использовано недавно, его можно найти в списке недавно
использованных приложений, который вызывается нажатием на третью
кнопку на панели внизу (см. рис. 6.1).


```
Рис. 6.1. Домашний экран, экран всех приложений и список недавно
использовавшихся приложений
```
В нижней и верхней частях экрана находятся системные панели,
предназначенные для размещения уведомлений и навигации по устройству.
Нижняя панель (Navigation Bar) предназначена для навигации на тех
устройствах, которые не имеют аппаратных навигационных клавиш (все
современные устройства). Верхняя часть экрана (Status Bar) предназначена для
вывода различных сведений, например, времени, уровня заряда батареи,
сигнала сотовой сети, а так же информационных сообщений.


```
Рис. 6.2. Информационная (1) и навигационная (2) панели
```
Уведомления - это быстрые сообщения, к которым пользователь может
получить доступ в любое время из информационной панели. Это могут быть
сообщения об обновлениях или других важных сообщениях, которые не
настолько серьезны, чтобы прерывать работу пользователя. Но к ним легко
можно получить доступ, потянув вниз верхнюю панель. Нажатие на
уведомление вызывает соответствующее сообщение.

```
6 .3 Шрифты
```
В дизайне Android используются традиционные типографические
инструменты, такие как масштаб, разреженность и выравнивание по сетке.
Успешное применение этих выразительных средств помогает пользователю
воспринимать информацию быстрее. В версии Android 4.0 Ice Cream Sandwich
была представлена шрифтовая гарнитура без засечек Roboto, специально
разработанная для экранов с высоким разрешением. Набор шрифтов доступен


для бесплатной загрузки. Гарнитура включает в себя прямое и наклонное
начертания для шрифтов различной ширины (см. рис. 6.3).

```
Рис. 6.3. Шрифт Roboto и его возможные варианты
```
```
6 .4 Масштабирование
```
Устройства различаются не только физическими размерами. Важным
параметром является плотность экрана (DPI - количество точек на дюйм).
Выделяют несколько категорий плотности экрана для Android-устройств:
LDPI, MDPI, HDPI, XHDPI, XXHDPI, и XXXHDPI. Чтобы элементы
интерфейса имели одинаковый физический размер на экранах разных
устройств, компания Google ввела абстрактную единицу измерения - DP
(независимый от разрешения пиксель). Один DP равен одному пикселю на
экране типа MDPI. Устройства, имеющие меньше 600dp по короткой стороне,
считаются телефонами, в противном случае мы говорим о планшетах (см. рис.
6.4).


```
Рис. 6.4. Размеры экранов телефонов и планшетов
```
Соответствие размеров экранов и их плотностей представлено в таблице
3 :
Таблица 3.
Плотности и размеры экранов
**No Обозначение Название Соответствие** 1 dp =
1 LDPI Low density 120 dpi 0,75 пикселя
2 MDPI Medium density 160 dpi 1 пиксель
3 HDPI High density 240 dpi 1,5 пикселя
4 XHDPI Extra-high density 320 dpi 2 пикселя
5 XXHDPI Extra-extra!-high density 480 dpi 3 пикселя
6 XXXHDPI Extra-extra-extra!-high density 640 dpi 4 пикселя

Минимальный размер элемента управления - 48dp. Такое значение
обусловлено тем, что на реальном устройстве оно соответствует 7- 10
миллиметрам. При управлении кончиками пальцев такой размер является
минимальным для отделения нужного элемента от всех остальных. Если
какой-то из размеров элемента управления должен быть больше, чем 48dp,
рекомендуется делать его размеры кратным этому значению (см. рис. 6.5).


```
Рис. 6.5. Размеры элемента управления кратны 48dp
```
Расстояние между элементами управления рекомендуется делать
кратным 8dp (см. рис. 6. 6 ).

```
Рис. 6. 6. Пример расположения элементов управления
```
Прочие нюансы дизайна для Android рассмотрены в лабораторной
работе.


```
Лекция 7. Основы разработки интерфейсов мобильных приложений
```
7. **1 Визуальный дизайн интерфейсов**

Силы, вложенные в разработку модели поведения программного
продукта, будут потрачены впустую, если вы не сумеете должным образом
донести до пользователей принципы этого поведения. В случае мобильных
продуктов это делается визуальными средствами - путем отображения
объектов на дисплее (в некоторых случаях целесообразно использовать
тактильные ощущения от нажатия).
Визуальный _дизайн_ интерфейсов - очень нужная и уникальная
дисциплина, которую следует применять в сочетании с проектированием
взаимодействия и промышленным дизайном. Она способна серьезно повлиять
на эффективность и привлекательность продукта, но для полной реализации
этого потенциала нужно не откладывать визуальный _дизайн_ на потом, а
сделать его одним из основных инструментов удовлетворения потребностей
пользователей и бизнеса.

7. **1.1 Изобразительное искусство, визуальный дизайн интерфейсов и**
    **прочие дисциплины дизайна**

Художники и визуальные дизайнеры работают с одними и теми же
изобразительными средствами, однако их деятельность служит различным
целям. Цель художника - создать объект, взгляд на который вызывает
эстетический отклик. Изобразительное искусство - способ самовыражения
художника. Художник не связан почти никакими ограничениями. Чем
необычнее и своеобразнее продукт его усилий, тем выше он ценится.
Дизайнеры создают объекты, которыми будут пользоваться другие
люди. Если говорить о дизайнерах визуальных интерфейсов, то они ищут
наилучшее представление, доносящее информацию о поведении программы,


в проектировании которой они принимают участие. Придерживаясь
целеориентированного подхода, они должны стремиться представлять
поведение и информацию в понятном и полезном виде, который поддерживает
маркетинговые цели организации и эмоциональные цели персонажей.
Разумеется, визуальный дизайн пользовательских интерфейсов не исключает
эстетических соображений, но такие соображения не должны выходить за
рамки функционального каркаса.

7. **1.2 Графический дизайн и пользовательские интерфейсы**

Графические дизайнеры обычно очень хорошо разбираются в
визуальных аспектах и хуже представляют себе понятия, лежащие в основе
поведения программного продукта и взаимодействия с ним. Они способны
создавать красивую и адекватную внешность интерфейсов, а кроме того -
привносить фирменный стиль во внешний вид и поведение программного
продукта. Для таких специалистов дизайн или проектирование интерфейса
есть в первую очередь тон, стиль, композиция, которые являются атрибутами
бренда, во вторую очередь - прозрачность и понятность информации и лишь
затем - передача информации о поведении посредством ожидаемого
назначения.
Дизайнерам визуальной части интерфейса необходимы некоторые
навыки, которые присущи графическим дизайнерам, но они должны еще
обладать глубоким пониманием и правильным восприятием роли поведения.
Их усилия в значительной степени сосредоточены на организационных
аспектах проектирования. В центре их внимания находится соответствие
между визуальной структурой интерфейса с одной стороны и логической
структурой пользовательской ментальной модели и поведения программы - с
другой. Кроме того, их заботит вопрос о том, как сообщать пользователю о
состояниях программы и что делать с когнитивными аспектами
пользовательского восприятия функций.


7. **1.3 Визуальный информационный дизайн**

Информационные дизайнеры работают над визуализацией данных,
содержимого и средств навигации. Усилия информационного дизайнера
направлены на то, чтобы представить данные в форме, способствующей их
верному истолкованию. Результат достигается через управление визуальной
иерархией при помощи таких средств, как цвет, форма, расположение и
масштаб. Распространенными объектами информационного дизайна являются
всевозможные графики, диаграммы и прочие способы отображения
количественной информации.
Чтобы создавать привлекательные и удобные пользовательские
интерфейсы, дизайнер интерфейсов должен владеть базовыми визуальными
навыками - пониманием цвета, типографики, формы и композиции - и знать,
как их можно эффективно применять для передачи поведения и представления
информации, для создания настроения и стимулирования физиологических
реакций. Дизайнеру интерфейса также требуется глубокое понимание
принципов взаимодействия и идиом интерфейса, определяющих поведение
продукта.

7. **2 Строительные блоки визуального дизайна интерфейсов**

_Дизайн_ интерфейсов сводится к вопросу о том, как оформить и
расположить визуальные элементы таким образом, чтобы внятно отразить
поведение и представить информацию. Каждый элемент визуальной
композиции имеет ряд свойств, и сочетание этих свойств придает элементу
смысл. _Пользователь_ получает возможность разобраться в интерфейсе
благодаря различным способам приложения этих свойств к каждому из
элементов интерфейса. В тех случаях, когда два объекта обладают общими
свойствами, _пользователь_ предположит, что эти объекты связаны или похожи.


Когда пользователи видят, что свойства отличаются, они предполагают, что
объекты не связаны.
Создавая пользовательский _интерфейс_ , проанализируйте
перечисленные ниже визуальные свойства каждого элемента или группы
элементов. Чтобы создать полезный и привлекательный
пользовательский _интерфейс_ , следует тщательно поработать с каждым из
этих свойств.

7. **2.1 Форма**

Форма - главный признак сущности объекта для человека. Мы узнаем
объекты по контурам. Если мы увидим на картинке синий ананас, мы его сразу
опознаем, потому что мы помним его форму. И лишь потом мы удивимся
странному цвету (см. рис. 7. 1 ). При этом различение форм требует большей
концентрация внимания, чем анализ цвета или размера. Поэтому форма - не
лучшее свойство для создания контраста, если требуется привлечь внимание
пользователя.

```
Рис. 7.1. В первую очередь мы видим ананас, а уже потом начинаем
задумываться, почему он синий
```

7. **2.2 Размер**

Более крупные элементы привлекают больше внимания, особенно если
они значительно превосходят размерами окружающие элементы. Люди
автоматически упорядочивают объекты по размеру и склонны оценивать их по
размеру; если у нас есть текст в четырех размерах, предполагается, что
относительная важность текста растет вместе с размером и что полужирный
текст более важен, чем текст с нормальным начертанием. Таким образом,
размер - полезное свойство для обозначения информационных иерархий.

7. **2.3 Цвет**

Цветовые различия быстро привлекают внимание. В некоторых
профессиональных областях цвета имеют конкретные значения, и этим можно
пользоваться. Так, для бухгалтера красный цвет - отрицательные результаты,
а черный - положительные.
Цвета приобретают смыслы и благодаря социальным контекстам, в
которых проходит наше взросление. Например, белый цвет на Западе
ассоциируется с чистотой и миром, а в Азии и арабских странах - с похоронами
и смертью. При этом цвет изначально не обладает свойством упорядоченности
и не выражается количественно, поэтому далеко не идеален для передачи
информации такого рода. Кроме того, не следует делать цвет единственным
способом передачи информации, поскольку цветовая слепота встречается
довольно часто.
Применяйте цвет с умом. Чтобы создать эффективную визуальную
систему, позволяющую пользователю выявлять сходства и различия объектов,
используйте ограниченный набор цветов - эффект радуги перегружает
восприятие пользователя и ограничивает возможности по передаче ему
информации.


Выбор цветовой палитры для программы необходимо проводить очень
осторожно. По разным данным, той или иной формой цветовой слепоты
страдают до 10% мужчин, и использование, например, красного и зеленого
цветов для указания контраста затрудняет работу с приложением для этих
людей.

7. **2.4 Яркость**

Понятия темного и светлого обретают смысл преимущественно в
контексте яркости фона. На темном фоне темный текст почти не виден, тогда
как на светлом он будет резко выделяться. Контрастность люди воспринимают
легко и быстро, так что значение яркости может стать хорошим инструментом
привлечения внимания к тем элементам, которые требуется подчеркнуть.
Значение яркости - также упорядоченная переменная, например, более темные
(с более низкой яркостью) цвета на карте легко интерпретируются: они
обозначают большие глубины или большие значения других параметров.

7. **2.5 Направление**

Направление полезно, когда требуется передавать информацию об
ориентации (вверх или вниз, вперед или назад). Помните, что восприятие
направления может быть затруднено в случае некоторых форм и при малых
размерах объектов, поэтому ее лучше использовать в качестве вторичного
признака. Так, если требуется показать, что рынок акций пошел вниз, можно
использовать направленную вниз стрелку красного цвета.

7. **2.6 Текстура**

Разумеется, изображенные на экране элементы не обладают настоящей
текстурой, но способны создавать ее видимость. Текстура редко бывает


полезна для передачи различий или привлечения внимания, поскольку требует
значительной концентрации на деталях. И тем не менее текстура может быть
важной подсказкой. Засечки и выпуклости на элементах пользовательского
интерфейса обычно указывают, что элемент можно перетаскивать, а фаски или
тени у кнопки усиливают ощущение, что ее можно нажать.

7. **2.7 Расположение**

Расположение - это переменная, упорядоченная и выражаемая
количественно, а значит, полезная для передачи иерархии. Расположение
также может служить средством создания пространственных отношений
между объектами на экране и объектами реального мира (например, небо в
верхней половине, земля в нижней).
Расположение элементов мобильного приложения очень сильно влияет
на удобство использования и зависит от того, как пользователь будет держать
устройство (см. рис. 7. 2 ). Подробнее об этом будет рассказано в продолжении
данного курса.

```
Рис. 7.2. Различные варианты удержания смартфона
```
7. **3 Элементы управления и дизайн навигации**

_Элементы управления_ - это доступные для манипулирования
самодостаточные экранные объекты, посредством которых люди
взаимодействуют с цифровыми продуктами. _Элементы управления_ (controls,


другое название - widgets - сокращение от windows gadgets - оконные
приспособления) - это базовые строительные блоки графического
пользовательского интерфейса.
Рассматривая _элементы управления_ с учетом целей пользователя, их
можно разбить на четыре основные категории:

- **командные элементы управления** , применяемые для выполнения
функций;
- **элементы выбора** , позволяющие выбирать данные или настройки;
- **элементы ввода** , применяемые для ввода данных;
- **элементы отображения** , используемые для наглядного
непосредственного манипулирования.
Некоторые _элементы управления_ сочетают в себе свойства более чем
одной категории.
7. **3.1 Командные элементы управления**

Командные элементы управления выполняют действия, причем делают
это немедленно. Главным и по сути единственным командным элементом
является кнопка, которая обладает множеством вариантов отображения.
Элементы меню также являются командными идиомами.
**Кнопки**
Кнопки обычно легко опознаются благодаря их псевдотрехмерности
(рис. 7.3). Действие выполняется сразу после нажатия на кнопку. Часто
особым образом выделяется кнопка по умолчанию, соответствующая
наиболее часто используемому действию.


**Рис.** 7. 3 Скриншоты популярной игры "Cut the Rope". Кнопки кажутся
выпуклыми, а нажатая кнопка меняет цвет
Кнопка - удобный и привлекательный с визуальной точки зрения
элемент управления. Весь ее облик подсказывает, что на нее можно нажать, и
это характеризует ее ожидаемое назначение. Рекомендуется изменять
внешний вид нажатой кнопки, так как это облегчает понимание работы
программы пользователем.
**Кнопки** - **значки**
Кнопки, помещенные на панель инструментов, обычно становятся
квадратными, теряют текстовую надпись и обзаводятся пиктограммой -
пояснением в виде графического значка ( рис. 7. 4 ).

```
Рис. 7. 4. Кнопки-значки в Android-приложении Twitter
```

Считается, что кнопки-значки очень удобны: они постоянно на виду и
взаимодействовать с ними проще, чем с элементами раскрывающегося меню.
Поскольку они постоянно видны, то легко запоминаются. У большинства
пользователей не возникает вопросов относительно ожидаемого назначения
кнопки. Проблема в том, что изображение на кнопке иногда бывает
непонятным. Например, пиктограмма с изображением дискеты, традиционно
обозначающая сохранение, часто непонятна молодым пользователям, которые
никогда не работали с реальными дискетами.
**Гиперссылки**
Текстовые гиперссылки - распространенный способ навигации в сети и
веб-приложениях, однако при программировании для мобильных устройств
их следует избегать. Дело в том, что попасть по ссылке пальцем с первого раза
часто затруднительно и пользователей раздражает необходимость повторения
этих действий.

7. **3.2 Элементы управления выбором**

Элементы выбора позволяют пользователю выбрать из группы
допустимых объектов тот, с которым будет совершено действие. Элементы
выбора применяются также для действий по настройке. Распространенными
элементами выбора являются флажки и списки.
Раньше использование элементов управления выбором не приводило к
немедленному выполнению действий - требовалась еще и активация
командного элемента. Сейчас возможны оба варианта. Если желательно дать
пользователю возможность несколько раз осуществить выбор перед
выполнением действия, следует создать явный командный элемент
управления (кнопку). Если же пользователю полезно сразу видеть результат
своих действий, и эти действия легко отменить, разумно сделать так, чтобы
элемент выбора играл также и роль командного элемента.


**Флажки**
Назначение флажка очевидно. Щелкнув по флажку, пользователь
немедленно увидит появившуюся галочку. Флажок прост, нагляден и изящен,
однако основан на тексте. Качественный текст может исключить возможность
неоднозначного толкования флажка. Однако этот же поясняющий текст
вынуждает пользователя замедляться для прочтения, а также занимает
значительное экранное пространство.
Традиционно флажки имеют квадратную форму. Не забывайте, что
пользователи распознают визуальные объекты по форме, и квадратная форма
флажков - важный стандарт.
**Выключатели**
Существует возможность сделать флажок более наглядным, применив в
качестве основы кнопку-значок, которая может фиксироваться в нажатом
состоянии. Такой элемент называется **выключателем** ( рис. 7. 5 ).

```
Рис. 7. 5. Один из самых распространенных выключателей - кнопка "Pause" в
играх
```
Состояние выключателя остается неизменным до следующего щелчка.
Выключатели экономно расходуют экранное пространство: они занимают
меньше места, потому что их назначение описывается не с помощью текста, а


посредством визуальных средств. Разумеется, это означает, что им присущ тот
же недостаток обычных кнопок-значков - неоднозначность пиктограмм.
**Триггеры**
Кнопки-триггеры - это разновидность элементов управления. Они
призваны экономить экранное пространство, к сожалению, ценой
значительной дезориентации пользователя. Классический пример -
размещение на одной кнопке функций воспроизведения и паузы для
музыкального проигрывателя. Подводным камнем такого подхода является то,
что элемент управления можно ошибочно посчитать индикатором состояния
проигрывателя ("на паузе" или "идет воспроизведение"). Элемент управления
может служить либо индикатором состояния, либо кнопкой переключения
состояний, но не тем и другим одновременно (рис. 7. 6 ).

```
Рис. 7.6. Если кнопка говорит "ВКЛЮЧЕНО", когда находится в состоянии
"выключено", то непонятно, в каком же состоянии находится кнопка. Если
кнопка говорит "ВЫКЛЮЧЕНО", когда находится в состоянии "выключено",
тогда возникает вопрос, где искать кнопку "ВКЛЮЧЕНО"?
```
**Радиокнопки**
Радиокнопки внешне похожи на флажки ( рис. 7. 7 ), но являются
взаимоисключающими, то есть выбор одного из вариантов автоматически
аннулирует предыдущий выбор. В каждый момент времени может быть
выбрана только одна кнопка. Радиокнопки всегда объединяются в группы из
двух или более радиокнопок, причем в каждой группе одна радиокнопка
всегда выбрана. Радиокнопки всегда круглые по той же причине, по которой
флажки всегда имеют квадратную форму: именно такими они были
изначально.
Радиокнопки занимают даже больше места, чем флажки, однако в
некоторых случаях такой расход экранного пространства оправдан.


Кнопка-значок преобразовала радиокнопки так же, как флажки, заменив
их в основном интерфейсе приложения. Если два или более выключателя
объединены схемой взаимного исключения - так, чтобы в каждый момент мог
быть включен лишь один из них, - они ведут себя точно так же, как
радиокнопки. Так образуются **радиокнопки со значками**. Элементы
управления цветом в Adobe Photoshop - хороший пример радиокнопок со
значками ( рис. 7. 8 ).

```
Рис. 7.7. Радиокнопки Android-приложения Dr.Web
```

```
Рис. 7.8. Элементы управления цветом в Android-приложении Adobe
Photoshop представляют собой группу радиокнопок со значками
```
**Списки**
Элементы управления типа "список" позволяют осуществлять выбор из
конечного множества текстовых строк, каждая из которых представляет
команду, объект или признак. Подобно радиокнопкам, списки - мощный
инструмент, упрощающий взаимодействие за счет устранения возможности
неправильного выбора. Списки - это небольшие текстовые области с полосой
прокрутки, автоматически подключаемой при необходимости ( рис. 7. 9 ).
Пользователь может выбрать единственную строку текста, нажав на нее.

```
Рис. 7.9. Стандартный список в Android
```

**Раскрывающийся список** - повсеместно встречающийся вариант
обычного списка. Он показывает лишь выбранный элемент в одну строку, но
если нажать на стрелку, открываются другие варианты выбора.
Элемент управления **представление в виде списка** предоставляет
возможность сопровождать каждую строку текста пиктограммой. Такая
возможность весьма полезна - существует множество ситуаций, когда можно
упростить работу пользователя, располагая графические идентификаторы
рядом со строками важных вариантов выбора ( рис. 7. 10 ).

```
Рис. 7.10. Элемент управления типа "список" с пиктограммами в Android-
приложении, позволяющий визуально оценивать погоду в различных городах
```
**Комбо** - **списки и комбо** - **кнопки**
Комбо-элементы представляют собой сочетание элементов. Комбо-
кнопка - разновидность радиокнопки со значком. Обычно она выглядит как


кнопка-значок с небольшой стрелкой, но если нажать на стрелку и удерживать
ее в нажатом состоянии, разворачивается меню.
Комбо-список представляет собой сочетание списка и поля
редактирования ( рис. 7. 11 ).

```
Рис. 7.11. Раскрывающееся поле со списком в Android-приложении ABBYY
Translator позволяет выбрать нужный язык из списка
```
Вариант с раскрывающимся списком значительно экономит экранное
пространство. Комбо-список хорошо подходит для тех случаев, когда
необходимо организовать выбор единственного объекта.

7. **3.3 Элементы ввода**


Элементы ввода дают пользователю возможность не только выбирать
существующие сведения, но и вводить новую информацию. Самый простой
элемент - поле редактирования текста (поле ввода). В эту категорию попадают
также такие элементы управления, как счетчики и ползунки.
**Ограничивающие элементы ввода**
Любой элемент управления, ограничивающий набор значений,
доступных для ввода пользователем, является ограничивающим элементом
ввода. Так, например, ползунок со шкалой значений от 0 до 100 является
ограничивающим элементом ввода. Независимо от действий пользователя не
может быть введено число, выходящее за диапазон определенных программой
значений. Проще говоря, ограничивающие элементы ввода должны
использоваться везде, где необходимо ограничить множество допустимых
значений.
Ограничивающий элемент ввода должен четко информировать
пользователя о допустимых границах. Текстовое поле, которое отвергает ввод
пользователя после того, как он выполнил ввод, не может считаться
ограничивающим элементом управления. Если пользователь должен выразить
выбор числовым значением в определенных границах, предоставьте ему
элемент управления, сообщающий об этих границах и предотвращающий ввод
недопустимых значений. Такую возможность дает ползунок. Ползунок
позволяет пользователю определять числовые значения в относительных
терминах, а не в результате непосредственного ввода с клавиатуры. Но для
ввода точных значений лучше подходят счетчики.
**Счетчики**
Счетчик состоит из небольшого поля ввода и двух прикрепленных к
нему кнопок ( рис. 7. 12 ). Благодаря счетчикам грань между ограничивающими
и неограничивающими элементами ввода данных становится размытой.
Маленькие кнопки со стрелками позволяют пользователю изменять значение
в поле редактирования небольшими шагами. Эти шаги могут выполняться до
определенного предела: значение не может превысить максимум,


установленный программой, или стать меньше установленного минимума.
Если пользователь пожелает ввести определенное число, он может сделать это
за счет прямого ввода числа в поле редактирования.

```
Рис. 7.12. Реализация счетчиков в Android-приложении Quickoffice
```
**Рукоятки и ползунки**
Рукоятки и ползунки очень эффективно расходуют экранное
пространство, и оба этих элемента управления замечательно справляются с
задачей обеспечения визуальной обратной связи по настройкам ( рис. 7. 13 ).
Ползунки и рукоятки применяются в основном в качестве ограничивающих
элементов управления ввода. Например, ползунки - превосходное средство
для действий, связанных с масштабированием.


```
Рис. 7.13. Ползунок в Android-приложении Winamp осуществляет перемотку
воспроизводимой композиции
```
**Неограничивающие элементы ввода**
Пожалуй, главный неограничивающий элемент ввода - поле ввода
текста. Этот простейший элемент управления позволяет пользователям
набирать любые алфавитно-цифровые строки. Как правило, поля ввода - это
небольшие области, внутри которых можно набрать одно-два слова, но они
могут быть реализованы и в виде довольно сложных текстовых редакторов.
Когда пользователю предложено неограничивающее текстовое поле
ввода, которое при этом принимает лишь строки определенного формата,
вероятно, имеется необходимость помочь пользователям вводить
"допустимые" строки. Имеется множество стандартных форматов вводимых
данных - даты, телефонные номера, почтовые индексы, номера социального


страхования. Ключ к успешному проектированию элемента ввода с проверкой
данных - в хорошо развитой обратной связи с пользователем.

7. **3.4 Элементы управления отображением**

Элементы управления отображением используются для управления
визуальным представлением информации на экране. Типичными примерами
элементов отображения являются разделители и полосы прокрутки. Сюда же
входят разделители страниц, линейки, направляющие, сетки и рамки.
**Текстовые элементы**
Вероятно, самый простой элемент управления отображением - элемент
вывода текстовой информации, который отображает текстовое сообщение в
некоторой позиции на экране. Он предоставляет текстовые метки для других
элементов управления и выводит данные, которые не могут или не должны
быть изменены пользователем. Единственная серьезная проблема этого
элемента состоит в том, что он зачастую используется там, где должны
присутствовать элементы ввода (и наоборот).
**Полосы прокрутки**
Полосы прокрутки служат важной цели - они позволяют осмысленным
образом помещать большие объемы информации внутри рамок окон и
панелей. К сожалению, они расходуют экранное пространство и ими сложно
манипулировать. Однако замечательное преимущество полосы прокрутки
состоит в создании контекста текущего положения в окне. Бегунок полосы
прокрутки указывает текущее положение и нередко масштаб "территории",
доступной для прокрутки.
**Разделители**
Разделители - удобный инструмент для разделения главного окна
приложения на несколько связанных между собой панелей, в каждой из
которых можно просматривать, изменять или переносить ту или иную
информацию. Подвижные разделители всегда должны сообщать о своей


подвижности посредством изменения формы курсора. Однако следует
проявлять осторожность, выбирая, какие именно разделители должны стать
подвижными. В общем случае разделитель не должен перемещаться таким
образом, чтобы содержимое панели становилось непригодным к
использованию.
**Выдвижные панели**
Выдвижные панели - это панели приложения, которые можно открывать
и закрывать в одно действие. Выдвижные панели - замечательное место для
элементов управления и функций, которые используются совместно с
основной рабочей областью приложения, но не столь часто. Выдвижные
панели более удобны, чем диалоговые окна, так как не закрывают основное
окно (рис. 7.14).

```
Рис. 7.14. Скриншоты популярной игры "Cut the Rope". Новостная панель
появляется, если потянуть за кольцо
```
(^)


```
Лекция 8. Элементы экрана, layout-файл, xml, ориентация экрана
```
**8.1 Элементы экрана**
Давайте посмотрим, как в Андроид приложениях формируется то, что
мы видим на экране.
Если проводить аналогию с Windows, то приложение состоит из окон,
называемых **Activity**. В конкретный момент времени обычно отображается
одно Activity и занимает весь экран, а приложение переключается между
ними. В качестве примера можно рассмотреть почтовое приложение. В нем
одно Activity – список писем, другое – просмотр письма, третье – настройки
ящика. При работе вы перемещаетесь по ним.
Содержимое Activity формируется из различных компонентов,
называемых **View**. Самые распространенные View - это кнопка, поле ввода,
чекбокс и т.д.
Примерно это можно изобразить так:

Необходимо заметить, что View обычно размещаются в **ViewGroup**.
Самый распространенный пример ViewGroup – это **Layout**. Layout бывает
различных типов и отвечает за то, как будут расположены его дочерние View
на экране (таблицей, строкой, столбцом ...)


Подробней об этом можно почитать в хелпе: **User Interface** и **Common
Layout Objects**.
Наверно уже запутал новыми словами и терминами, давайте посмотрим
это все на практике. Создадим проект со следующими свойствами:

**_Project name_** _: P0041_BasicViews_
**_Build Target_** _: Android 2.3.3_
**_Application name_** _: BasicViews_
**_Package name_** _: ru.startandroid.develop.BasicViews_
**_Create Activity_** _: MainActivity_

Если у вас свежая версия визарда создания проекта, то **Build Target** -
это то же самое, что и **Build SDK**. А в экране создания Activity не забывайте
указывать **main** в поле **Layout Name**.
В нашем проекте нам интересен файл: **res > layout > main.xml**

Это **layout-файл** , в нем мы определяем набор и расположение
элементов View, которые хотим видеть на экране. При запуске приложения,
Activity читает этот файл и отображает нам то, что мы настроили. Давайте
откроем его и посмотрим, какой набор View он содержит по умолчанию.


Слева видим список View, разделенный на группы. Здесь отображены
все View-элементы, которые вы можете использовать в своих приложениях.
Возможно, у вас он будет немного другого вида. Это регулируется в
меню Palette, чуть выше.


Обратим внимание на белый экран. Мы видим, что на экране сейчас
присутствует элемент с текстом Hello world! Чтобы узнать, что это за View
нажмите на этот текст. Справа во вкладке **Outline** вы видите все элементы,
которые описаны в main.xml.

Видим, что выделенный нами элемент – это **TextView**. Обратите
внимание, что он вложен в элемент **RelativeLayout** – это ViewGroup, про
которые я писал выше.
Добавим еще элементов на экран, пусть это будут **Button** и **CheckBox**.
Для этого просто перетащите их из списка слева на белый экран вашего
будущего приложения. Также можно перетащить их на RelativeLayout во


вкладке Outline, результат будет почти тот же. Кроме Button и CheckBox,
добавим еще на экран **Plain Text** из группы **Text Fields**.
В Outline они появятся под названиями **button1** , **checkBox1** и **editText1**.
Это **ID** , которые им были присвоены автоматически. Пока оставим их
такими, позднее научимся их менять и будем делать более осмысленными.
Теперь на нашем экране несколько элементов. Давайте изменим
надписи на них. Во вкладке Outline жмем на TextView. Теперь нам нужна
вкладка **Properties**. Она отображает свойства выделенного в Outline или на
экране View-элемента. Располагается она обычно сразу под Outline.
Найдем в Properties свойство **Text**. Сейчас там стоит ссылка на
текстовую константу. Где создаются эти константы мы рассмотрим в
следующих уроках, а пока просто давайте напишем сюда свой текст: «Какой-
то текст»

Аналогично изменим свойство Text для элементов button1, checkBox1 и
editText1 на произвольные тексты. Все эти изменения пишутся в main.xml.
Сохраним все CTRL+SHIFT+S и запустим CTRL+F11.
Приложение отображает нам MainActivity, а оно в свою очередь читает
файл main.xml и отображает все View, которые мы создавали и настраивали.


**8.2 Какой layout-файл используется в Activity**
На прошлом уроке мы выяснили, что Activity читает layout-файл и
отображает то, что в нем сконфигурировано. Теперь выясним, откуда Activity
знает, какой именно layout-файл читать. А еще в этом уроке находится
подсказка, как зарегиться на нашем форуме ;)
_В этом уроке мы будем поворачивать экран. Эмулятор версии 2.3.3,
который мы успешно применяли и будем применять для тестирования
наших приложений, имеет глюк. Он не хочет корректно поворачивать
экран. Поэтому вспомните, плз, урок 3 и создайте еще один эмулятор версии
2.2, например. Соответственно при создании проекта, тоже указываем
версию 2.2. Скрины сделаны на версии 2.3.3 - не обращайте внимания на это._
Создадим новый проект:

**_Project name_** _: P0051_LayoutFiles_
**_Build Target_** _: Android 2.2_


**_Application name_** _: LayoutFiles_
**_Package name_** _: ru.startandroid.develop.LayoutFiles_
**_Create Activity_** _: MainActivity_

При разработке каждому Activity сопоставляется одноименный java-
класс ( **наследник** класса **android.app.Activity** ). При запуске приложения,
когда система должна показать Activity и в дальнейшем работать с ним, она
будет вызывать методы этого класса. И от того, что мы в этих методах
накодим, зависит поведение Activity.
При создании проекта мы указывали, что надо создать Activity с
именем **MainActivity**
При использовании старого визарда это выглядело так:

В новом визарде - чуть по другому. На одном экране галка, на другом -
имя:


Мы попросили создать Activity и Eclipse создал нам соответствующий
класс (в дальнейшем мы научимся их создавать самостоятельно).
Давайте посмотрим этот класс: откроем двойным кликом
файл **src/ru.startandroid.develop.LayoutFiles/MainActivity.java**

В нашем классе мы видим, что реализован метод **onCreate** – он
вызывается, когда приложение создает и отображает Activity (на


onCreateOptionsMenu пока не обращаем внимания). Посмотрим код
реализации.
Первая строка:
_super.onCreate(savedInstanceState);_ – конструктор родительского
класса, выполняющий необходимые процедуры, его мы не трогаем.
Нас интересует этот код:
_setContentView(R.layout.main);_
Метод **setContentView(int)** – устанавливает содержимое Activity из
layout-файла. Но в качестве аргумента мы указываем не путь к нашему
layout-файлу (res/layout/main.xml), а константу, которая является ID файла.
Это константа генерируется автоматически
здесь **gen/ru.startandroid.develop.LayoutFiles/R.java**.

Этот файл можно открыть и посмотреть, но менять его не стоит.
В **R** классе будут храниться сгенерированные ID для всех ресурсов проекта
(из папки res/*), чтобы мы могли к ним обращаться. Имена этих ID-констант
совпадают с именами файлов ресурсов (без расширений).
Откроем **res/layout/main.xml** , посмотрим, что там


Запустим приложение и посмотрим что оно нам покажет


Все верно - Activity отобразил то, что прописано в **main.xml**.
Попробуем отобразить содержимое другого файла. Создадим еще один
layout-файл, например **myscreen.xml**. Для этого выделим папку res/layout в
нашем проекте и нажмем кнопку создания нового файла


```
Откроется визард
```
В поле File вводим имя файла: myscreen.xml и жмем Finish.
Новый layout-файл должен сразу открыться. Добавим **TextView** и
через **Properties** изменим его текст на: «Этот экран описан не в main.xml, а в
myscreen.xml».
При этом Eclipse будет подчеркивать этот текст желтым цветом и
ругаться примерно так: _[I18N] Hardcoded string "...", should use @string
resource_. Это он возмущен хардкодом, который мы тут устроили. Он хочет,
чтобы использовали файлы ресурсов для всех надписей. Но пока что мы это
не умеем, так что игнорируем эти предупреждения.


Обязательно сохраняем. Чтобы в R.java появилась новая константа для
этого файла - R.layout.myscreen.
Теперь настроим так, чтобы Activity использовало новый
файл **myscreen.xml** , а не **main.xml**. Откроем MainActivity.java и поменяем
аргумент метода **setContentView**. Замените « **R.layout.main** », на
« **R.layout.myscreen** » (ID нового layout-файла). Должно получиться так:


Сохраняем, запускаем приложение. Видим, что теперь оно отображает
содержимое из myscreen.xml, т.к. мы явно ему это указали в методе
setContentView, который выполняется при создании (onCreate) Activity

**8.3 Layout-файл в виде XML**
Открыв файл main.xml, вы видите его визуальное представление. Т.е.
некий предпросмотр, как это будет выглядеть на экране. Снизу вы можете
видеть две вкладки – **Graphical Layout** и **main.xml**. Откройте main.xml


Мы видим достаточно читабельное xml-описание всех View нашего
layout-файла. Названия xml-элементов - это классы View-элементов, xml-
атрибуты - это параметры View-элементов, т.е. все те параметры, что мы
меняем через вкладку Properties. Также вы можете вносить изменения прямо
сюда и изменения будут отображаться в Graphical Layout. Например изменим
текст у TextView. Вместо ссылки на константу, вставим свой текст «Какой-то
текст»


Сохраняем. Открываем Graphical Layout и наблюдаем изменения.


Обычно авторы учебников дают содержание layout-файлов именно в
xml виде. Это удобно – вы можете просто скопировать фрагмент и
использовать, и не надо вручную добавлять View-элементы, бегать по
Properties и настраивать все руками. Я буду делать в своих проектах также.

**8.4 Layout-файл при смене ориентации экрана**


По умолчанию мы настраиваем **layout-
файл** под **вертикальную** ориентацию экрана. Но что будет если мы
повернем смартфон и включится **горизонтальная** ориентация? Давайте
смотреть.
Изменим **myscreen.xml**. Добавим вертикальный ряд кнопок и изменим
надпись.
xml-код (вы можете скопировать его и вставить в ваш файл):
<?xml version= _"1.0"_ encoding= _"utf-8"_ ?>
<LinearLayout
xmlns:android= _"http://schemas.android.com/apk/res/android"_
android:orientation= _"vertical"_
android:layout_width= _"match_parent"_
android:layout_height= _"match_parent"_ >
<TextView
android:id= _"@+id/textView1"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:text= _"Вертикальная ориентация экрана"_ >
</TextView>
<LinearLayout
android:layout_height= _"wrap_content"_
android:layout_width= _"match_parent"_
android:id= _"@+id/linearLayout1"_
android:orientation= _"vertical"_ >
<Button
android:text= _"Button1"_
android:id= _"@+id/button1"_
android:layout_height= _"100dp"_
android:layout_width= _"100dp"_ >
</Button>
<Button
android:text= _"Button2"_
android:id= _"@+id/button2"_
android:layout_height= _"100dp"_
android:layout_width= _"100dp"_ >
</Button>
<Button
android:text= _"Button3"_
android:id= _"@+id/button3"_
android:layout_height= _"100dp"_
android:layout_width= _"100dp"_ >
</Button>


<Button
android:text= _"Button4"_
android:id= _"@+id/button4"_
android:layout_height= _"100dp"_
android:layout_width= _"100dp"_ >
</Button>
</LinearLayout>
</LinearLayout>

Обратите внимание - я добавил вертикальный **LinearLayout** и
поместил в него 4 кнопки. Подробнее обсудим это на следующем уроке.
Запустим приложение. В вертикальной ориентации все ок.

Нажмем в эмуляторе CTRL+F12, ориентация сменилась на
горизонтальную и наши кнопки уже не влезают в экран (эмулятор версии
2.3.3 глючит и смена ориентации срабатывает не всегда)


Т.е. нам необходим еще один layout-файл, который был бы заточен под
горизонтальную ориентацию и в нашем случае вывел бы кнопки
горизонтально.
Но как дать знать Activity, что она в вертикальной ориентации должна
использовать один layout-файл, а в горизонтальной – другой? Об этом за нас
уже подумали создатели Андроид. Необходимо создать папку **res/layout-
land** , а в ней создать layout файл **с тем же именем** , что и основной. Этот
файл будет использован в **горизонтальной** ориентации.
Создаем папку: правой кнопкой на **res** , New > Folder, Folder name
= **layout-land** , жмем Finish.


Далее создадим файл res/layout-land/myscreen.xml и настроим его под
горизонтальную ориентацию. Аналогично, как и в первый раз, жмем кнопку
создания файла. Откроется визард.
Вводим имя файла: **myscreen.xml**

Визард может ругнуться, что есть уже такой файл - _The destination file
already exists_. Это он углядел ранее созданный файл res/layout/myscreen.xml.
Нам надо ему сообщить, что новый файл предназначен для папки res/layout-
land, а не res/layout. Жмем **Next**
А здесь уже руками внизу допишите приставку **-land** , чтобы
получилось **res/layout-land**


Как вариант, можно было руками не дописывать, а добавить из левого
столбца в правый атрибут Orientation и указать ему значение
Landscape. Визард все понял бы и сам дописал к пути приставку -land.
А мы сами дописали путь и визард сам добавил атрибут направо.
Жмем **Finish** и получаем готовый файл.


Поместите этот xml-код в файл и сохраните файл, чтобы получить
такую же картинку, как выше:
<?xml version= _"1.0"_ encoding= _"utf-8"_ ?>
<LinearLayout
xmlns:android= _"http://schemas.android.com/apk/res/android"_
android:orientation= _"vertical"_
android:layout_width= _"match_parent"_
android:layout_height= _"match_parent"_ >
<TextView
android:id= _"@+id/textView1"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:text= _"Горизонтальная ориентация экрана"_ >
</TextView>
<LinearLayout
android:layout_height= _"wrap_content"_
android:layout_width= _"match_parent"_
android:id= _"@+id/linearLayout1"_
android:orientation= _"horizontal"_ >
<Button
android:text= _"Button1"_
android:id= _"@+id/button1"_
android:layout_height= _"100dp"_
android:layout_width= _"100dp"_ >
</Button>
<Button
android:text= _"Button2"_
android:id= _"@+id/button2"_
android:layout_height= _"100dp"_
android:layout_width= _"100dp"_ >
</Button>
<Button
android:text= _"Button3"_
android:id= _"@+id/button3"_
android:layout_height= _"100dp"_
android:layout_width= _"100dp"_ >
</Button>
<Button
android:text= _"Button4"_
android:id= _"@+id/button4"_
android:layout_height= _"100dp"_
android:layout_width= _"100dp"_ >
</Button>


</LinearLayout>
</LinearLayout>

Запустим приложение. Activity читает layout-файл, который мы
указывали в методе setContentView, т.е. myscreen.xml и отображает его
содержимое. Переключим ориентацию CTRL+F12. Activity понимает, что
находится в горизонтальной ориентации, ищет в папке layout-land файл
myscreen.xml и использует уже его.


```
Лекция 9. Виды Layouts. Ключевые отличия и свойства.
```
Расположение View-элементов на экране зависит
от **ViewGroup** (Layout), в которой они находятся. В этом уроке мы
рассмотрим основные виды **Layout**.
**LinearLayout** – отображает View-элементы в виде одной строки (если
он Horizontal) или одного столбца (если он Vertical). Я использовал это на
прошлом уроке, когда демонстрировал использование layout-файлов при
смене ориентации.
**TableLayout** – отображает элементы в виде таблицы, по строкам и
столбцам.
**RelativeLayout** – для каждого элемента настраивается его положение
относительно других элементов.
**AbsoluteLayout** – для каждого элемента указывается явная позиция на
экране в системе координат (x,y)
Рассмотрим эти виды.

**9.1 LinearLayout (LL)**
Этот вид ViewGroup по умолчанию предлагается при создании новых
layout-файлов. Он действительно удобен и достаточно гибок, чтобы
создавать экраны различной сложности. LL имеет свойство Orientation,
которое определяет, как будут расположены дочерние элементы –
горизонтальной или вертикальной линией.
Сделаем простой и наглядный пример.
Создайте проект:
**Project name** : P0061_Layouts
**Build Target** : Android 2.3.3
**Application name** : Layouts
**Package name** : ru.startandroid.develop.layouts
**Create Activity** : MainActivity


Откроем layout-файл **main.xml** , и поместите в него следующий код:
<?xml version= _"1.0"_ encoding= _"utf-8"_ ?>
<LinearLayout
xmlns:android= _"http://schemas.android.com/apk/res/android"_
xmlns:tools= _"http://schemas.android.com/tools"_
android:layout_width= _"match_parent"_
android:layout_height= _"match_parent"_
android:orientation= _"vertical"_ >
</LinearLayout>
Теперь корневой элемент у нас LinearLayout с вертикальной
ориентацией.
Перетащите слева в корневой LinearLayout три кнопки. Они
выстроились вертикально.

Теперь в Properties меняем для LL свойство **Orientation** на **horizontal** и
сохраняем (CTRL+SHIFT+S) – кнопки выстроились горизонтально.


GroupView можно вкладывать друг в друга. Вложим в один LL два
других. Удалите в main.xml все элементы (три кнопки) кроме корневого LL.
Ориентацию корневого LL укажем вертикальную и добавим в него два новых
горизонтальных LL. В списке элементов слева они находятся в разделе
Layouts. Напоминаю, что вы можете перетаскивать элементы из списка не
только на экран, но и на конкретный элемент на вкладке Outline.
В каждый горизонтальный LL добавим по три кнопки. Получилось два
горизонтальных ряда кнопок.

**9.2 TableLayout (TL)**


TL состоит из строк **TableRow** (TR). Каждая TR в свою очередь
содержит View-элементы, формирующие столбцы. Т.е. кол-во View в TR -
это кол-во столбцов. Но кол-во столбцов в таблице должно быть равным для
всех строк. Поэтому, если в разных TR разное кол-во View-элементов
(столбцов), то общее кол-во определяется по TR с максимальным кол-вом.
Рассмотрим на примере.
Создадим layout-файл **tlayout.xml**. с корневым элементом TableLayout

Добавим в корневой TableLayout три TableRow-строки (из раздела
Layouts слева) и в каждую строку добавим по две кнопки. Результат: наша
таблица имеет три строки и два столбца.


Добавим в первую строку еще пару кнопок. Кол-во столбцов для всех
строк теперь равно 4, т.к. оно определяется по строке с максимальным кол-
вом элементов, т.е. по первой строке. Для второй и третьей строки третий и
четвертый столбцы просто ничем не заполнены.

Во вторую строку добавим TextView и Button, и текст в добавленном
TextView сделаем пустым. В третьей строке сделаем тоже самое. Мы видим,
что эти элементы легли в третий и четвертый столбец. И т.к. TextView у нас
без текста и на экране не виден, кажется что третий столбец во второй и
третьей строке пустой.


Ширина столбца определяется по самому широкому элементу из этого
столбца. Введем текст в один из TextView и видим, что он расширил столбец.

Я уберу элементы четвертого столбца и построю такой экран.
Попробуйте сами сделать так же в качестве упражнения.


TL может содержать не только TR, но и обычные View. Добавьте,
например, Button прямо в TL, а не в TR и увидите, что она растянулась на
ширину всей таблицы.

**9.3 RelativeLayout (RL)**
В этом виде Layout каждый View-элемент может быть расположен
определенным образом относительно указанного View-элемента.
Виды отношений:
1) слева, справа, сверху, снизу указанного элемента (layout_toLeftOf,
layout_toRightOf, layout_above, layout_below)
2) выравненным по левому, правому, верхнему, нижнему краю
указанного элемента (layout_alignLeft, layout_alignRight, layout_alignTop,
layout_alignBottom)
3) выравненным по левому, правому, верхнему, нижнему краю
родителя (layout_alignParentLeft, layout_alignParentRight,
layout_alignParentTop, layout_alignParentBottom)
4) выравненным по центру вертикально, по центру горизонтально, по
центру вертикально и горизонтально относительно родителя
(layout_centerVertical, layout_centerHorizontal, layout_centerInParent)
Подробно можно почитать в **хелпе**.
Создадим **rlayout.xml** и скопируем туда такой xml-код:
<?xml version= _"1.0"_ encoding= _"utf-8"_ ?>
<RelativeLayout
xmlns:android= _"http://schemas.android.com/apk/res/android"_
android:layout_width= _"match_parent"_
android:layout_height= _"match_parent"_ >
<TextView
android:id= _"@+id/label"_
android:layout_width= _"match_parent"_
android:layout_height= _"wrap_content"_
android:text= _"Type here:"_ >
</TextView>
<EditText


android:id= _"@+id/entry"_
android:layout_width= _"match_parent"_
android:layout_height= _"wrap_content"_
android:layout_below= _"@+id/label"_
android:background= _"@android:drawable/editbox_background"_ >
</EditText>
<Button
android:id= _"@+id/ok"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:layout_alignParentRight= _"true"_
android:layout_below= _"@+id/entry"_
android:layout_marginLeft= _"10dip"_
android:text= _"OK"_ >
</Button>
<Button
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:layout_alignTop= _"@+id/ok"_
android:layout_toLeftOf= _"@+id/ok"_
android:text= _"Cancel"_ >
</Button>
</RelativeLayout>
Здесь у нас корневой элемент - RelativeLayout.
Получился такой экран:


Нам интересен xml-код. Сразу кратко опишу незнакомые атрибуты и
их значения:
android:layout_width= _"match_parent"_
android:layout_height= _"wrap_content"_
android:id= _"@+id/entry"_

- слово **android** в названии каждого аттрибута – это **namespace** , я его
буду опускать при объяснениях.
**- id** – это ID элемента,
**- layout_width** (ширина элемента) и **layout_height** (высота элемента)
могут задаваться в асболютных значениях, а могут быть
следующими: **fill_parent** (максимально возможная ширина или высота в
пределах родителя) и **wrap_content** (ширина или высота определяется по
содержимому элемента). В **хелпе** указывается, что есть еще **match_parent**.


Это тоже самое, что и fill_parent. По каким-то причинам, разработчики
системы решили, что название match_parent удобнее, и от fill_parent
постепенно будут отказываться. А пока его оставили для совместимости. Так
что запомните, что **match_parent = fill_parent** и в дальнейшем будем
стараться использовать **match_parent**. Позже мы еще остановимся на этом и
разберем подробнее.
Сейчас вернемся к нашим элементам. В примере мы видим TextView,
EditText и два Button – OK и Cancel. Давайте подробно разберем
интересующие нас атрибуты.
**TextView**
android:id= _"@+id/label"_ - ID
android:layout_width= _"match_parent"_ - занимает всю доступную ему ширину
(хоть это и не видно на экране);
android:layout_height= _"wrap_content"_ - высота по содержимому;
ни к чему никак не относится

**EditText**
android:id= _"@+id/entry"_ - ID
android:layout_width= _"match_parent"_ - вся доступная ему ширина
android:layout_height= _"wrap_content"_ - высота по содержимому
android:layout_below= _"@id/label"_ - расположен **ниже** TextView (ссылка по ID)

**Button_OK**
android:id= _"@+id/ok"_ – ID
android:layout_width= _"wrap_content"_ - ширина по содержимому
android:layout_height= _"wrap_content"_ – высота по содержимому
android:layout_below= _"@id/entry"_ - расположен ниже EditText
android:layout_alignParentRight= _"true"_ - **выравнен по правому краю
родителя**
android:layout_marginLeft= _"10dip"_ – имеет отступ слева (чтобы Button_Cancel
был не впритык)

**Button_Cancel**
android:layout_width= _"wrap_content"_ - ширина по содержимому
android:layout_height= _"wrap_content"_ – высота по содержимому
android:layout_toLeftOf= _"@id/ok"_ - расположен **слева** от Button_OK
android:layout_alignTop= _"@id/ok"_ - **выравнен по верхнему краю** Button_OK


Вы можете подобавлять элементы и поэкспериментировать с их
размещением.
Обратите внимание, что у View-элемента может не быть ID (android:id).
Например, для TextView он обычно не нужен, т.к. они чаще всего статичны и
мы к ним почти не обращаемся при работе приложения. Другое дело EditText

- мы работаем с содержимым текстового поля, и Button – нам надо
обрабатывать нажатия и соответственно знать, какая именно кнопка нажата.
В будущем мы увидим еще одну необходимость задания ID для View-
элемента.

**9.4 AbsoluteLayout (AL)**
Обеспечивает абсолютное позиционирование элементов на экране. Вы
указываете координаты для левого верхнего угла компонента.
Создадим **alayout.xml** с корневым AbsoluteLayout


Теперь попробуйте перетаскиванием подобавлять различные элементы
на экран. Они не выстраиваются, как при LinearLayout или TableLayout, а
ложатся там, куда вы их перетащили. Т.е. это абсолютное позиционирование.

Открываем xml-код и видим, что для задания координат
используются **layout_x** и **layout_y**.

<?xml version= _"1.0"_ encoding= _"utf-8"_ ?>
<AbsoluteLayout
xmlns:android= _"http://schemas.android.com/apk/res/android"_
android:layout_width= _"match_parent"_
android:layout_height= _"match_parent"_ >
<Button
android:id= _"@+id/button1"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_


android:layout_x= _"42dp"_
android:layout_y= _"62dp"_
android:text= _"Button"_ >
</Button>
<TextView
android:id= _"@+id/textView1"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:layout_x= _"142dp"_
android:layout_y= _"131dp"_
android:text= _"TextView"_ >
</TextView>
<CheckBox
android:id= _"@+id/checkBox1"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:layout_x= _"55dp"_
android:layout_y= _"212dp"_
android:text= _"CheckBox"_ >
</CheckBox>
<RadioButton
android:id= _"@+id/radioButton1"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:layout_x= _"171dp"_
android:layout_y= _"318dp"_
android:text= _"RadioButton"_ >
</RadioButton>
</AbsoluteLayout>

Поначалу кажется, что это наиболее удобный и интуитивно понятный
способ расположения элементов на экране - они сразу располагаются там где
надо. Но это только в случае, когда вы разрабатываете для экрана с
конкретным разрешением. Если открыть такое приложение на другом экране,
все элементы сместятся и получится не так, как вы планировали. Поэтому
этот Layout не рекомендуется использовать. И его совместимость с
будущими версиями Android не гарантируется.


Есть еще **много видов** ViewGroup, и мы постепенно будем их
осваивать. А пока нам хватит этих.

**9.5 Layout параметры для View-элементов.**
На этом уроке мы:

- разбираемся в характеристиках экрана
- рассматриваем layout параметры (высота, ширина, отступ, гравитация,
вес)
**Экраны**
Для начала немного теории по экранам. Экран имеет такие физические
характеристики как диагональ и разрешение. Диагональ – это расстояние
между противоположными углами экрана, обычно измеряется в дюймах.
Разрешение – кол-во точек по горизонтали и вертикали, которое экран
способен отобразить, измеряется в пикселах.
Возьмем в качестве примера экран смартфона HTC Desire. Диагональ =
3,7 дюйма, разрешение = 800х480 пикселов.

Кол-во пикселов в одном дюйме называется dpi (dot per inch). Узнаем
чему равно dpi в данном случае, вспомнив классику: c^2 = a^2 + b^2 , где с – кол-


во пикселей по диагонали, т.е. вмещаемое в 3,7 дюйма. a и b – стороны
экрана.
c = 3,7 * dpi
(3,7 * dpi)^2 = 480^2 + 800^2
dpi^2 = 870400 / 13,69 = 63579
dpi = 252. Т.е. в одном дюйме экрана помещается ряд из 252 пикселов.
Возвращаемся к теме урока. Рассмотрим подробно следующие
параметры View элементов

**Layout width и Layout height**
Про ширину (layout_width) и высоту (layout_height) мы уже немного
говорили на прошлом уроке. Мы можем указывать для них абсолютные
значения, а можем использовать константы. Разберем подробнее эти
возможности.
**Абсолютные значения:**
Используются следующие **единицы измерения** (ЕИ):
**dp** или **dip** - Density-independent Pixels. Абстрактная ЕИ, позволяющая
приложениям выглядеть одинаково на различных экранах и разрешениях.
**sp** - Scale-independent Pixels. То же, что и dp, только используется для
размеров шрифта в View элементах
**pt** - 1/72 дюйма, определяется по физическому размеру экрана. Эта
ЕИ **из типографии**.
**px** – пиксел, не рекомендуется использовать т.к. на разных экранах
приложение будет выглядеть по-разному.
**mm** – миллиметр, определяется по физическому размеру экрана


**in** – дюйм, определяется по физическому размеру экрана
**Константы**
match_parent (fill_parent) – означает, что элемент займет всю доступную
ему в родительском элементе ширину/высоту.
wrap_content – ширна/высота элемента будет определяться его
содержимым
Создадим проект:
**_Project name_** _: P0072_LayoutProp_
**_Build Target_** _: Android 2.3.3_
**_Application name_** _: LayoutProp_
**_Package name_** _: ru.startandroid.develop.layoutprop_
**_Create Activity_** _: MainActivity_

Открываем **main.xml**. Настроим корневой **LinearLayout** на
горизонтальную ориентацию, удалим **TextView** , и добавим **Button** с шириной
и высотой равной **wrap_content**. Она отображается на экране и ее ширина
соответствует тексту на ней.

Изменим текст с «Button» на «Button with text», сохраним и посмотрим
на экран.


Кнопка стала шире, т.к. ширина определяется по содержимому. Если
же мы сейчас явно укажем ей ширину 250 dp, то кнопка растянется
независимо от содержимого.

Теперь сделаем ширину равной **match_parent**. Кнопка растянулась на
всю **ширину родителя** , т.е. LinearLayout. А LinearLayout в свою очередь
занимет всю ширину экрана.


Если у нас родитель содержит несколько элементов и мы хотим, чтобы
они заняли все пространство необходимо использовать параметр **Layout
weight – вес**. Свободное пространство распределяется между элементами
пропорционально их weight-значениям.
Изменим текст нашей кнопки на **B1** и добавим ей соседа по
LinearLayout – вторую кнопку с текстом **B2**. Ширину для обоих
поставьте **wrap_content**

Займемся дележом. Если мы хотим, чтобы кнопки поделили
пространство родителя **поровну** – то для обеих укажем **weight** = 1. В этом
случае кнопки равны по ширине.

Обратите внимание, что не используются единицы измерения,
указываются просто числа.


Если нужно, чтобы B1 занимала четверть, а B2 три четверти
свободного пространства, то проставляем **weight** = 1 для **B1** и **weight** = 3
для **B2**.

Кол-во элементов может быть любым. Добавим еще кнопку с
текстом **B3** , **weight** = 2 и **width** = wrap_content.

xml-код получившегося экрана:
version= _"1.0"_ encoding= _"utf-8"_ ?>

xmlns:android= _"http://schemas.android.com/apk/res/android"_
android:layout_width= _"fill_parent"_
android:layout_height= _"fill_parent"_
android:orientation= _"horizontal"_ >

android:id= _"@+id/button1"_
android:layout_height= _"wrap_content"_
android:layout_width= _"wrap_content"_
android:text= _"B1"_


android:layout_weight= _"1"_ >

android:id= _"@+id/button2"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:text= _"B2"_
android:layout_weight= _"3"_ >

android:layout_height= _"wrap_content"_
android:layout_width= _"wrap_content"_
android:id= _"@+id/button3"_
android:text= _"B3"_
android:layout_weight= _"2"_ >

Теперь для **B2** и **B3** укажите **weight** = 0. Они больше не претендуют на
свободное пространство и занимают ширину по содержимому, а **B1** забирает
все себе.

Разумеется, все выше сказанное применимо и для параметра высоты -
**height**.
При использовании **weigth** вы можете указать
значение **height** или **width** = **0dp**. В этом случае не будет учитываться
содержимое элементов и результат будет более соответствующий
коэффициентам веса.


**9.6 Layout gravity**
Параметр layout_gravity аналогичен выравниванию из Word или Excel.
Удобнее всего продемонстрировать его с использованием **FrameLayout**. Я не
описывал этот Layout на прошлом уроке, т.к. он совсем простой. Все
помещаемые в него элементы он по умолчанию помещает в левый верхний
угол и никак их не выстраивает. Нам это очень подходит для демонстрации
настроек выравнивания.
Создадим **grlayout.xml** :
version= _"1.0"_ encoding= _"utf-8"_ ?>

xmlns:android= _"http://schemas.android.com/apk/res/android"_
android:orientation= _"vertical"_
android:layout_width= _"match_parent"_
android:layout_height= _"match_parent"_ >

android:id= _"@+id/frameLayout1"_
android:layout_width= _"match_parent"_
android:layout_height= _"match_parent"_ >

android:id= _"@+id/button1"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:layout_gravity= _"top|left"_
android:text= _"gravity = top left"_ >

android:id= _"@+id/button2"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:layout_gravity= _"top|right"_
android:text= _"gravity = top right"_ >


android:id= _"@+id/button3"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:layout_gravity= _"bottom|left"_
android:text= _"gravity = bottom left"_ >

android:id= _"@+id/button4"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:layout_gravity= _"bottom|right"_
android:text= _"gravity = bottom right"_ >

android:id= _"@+id/button5"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:layout_gravity= _"center"_
android:text= _"gravity = center"_ >

```
На экране видим:
```

Для наглядности текст кнопки отображает ее свойства. Все очевидно и
несложно.
Я честно пытался понять зачем нужны значения gravity **fill_*** и **clip_*** ,
но так и не понял. То, что написано про них в хелпе у меня не работает. Если
у вас есть сведения по этому поводу – пишите в каменты.

**9.7 Layout margin**
Параметры margin полностью аналогичны **margin** из **html**. Это отступ.
Он может быть со всех сторон сразу, либо только с необходимых сторон.
Продемонстрируем это на примере TableLayout.
Создадим **marginlayout.xml** и нарисуем таблицу три на три с кнопками.
version= _"1.0"_ encoding= _"utf-8"_ ?>

xmlns:android= _"http://schemas.android.com/apk/res/android"_
android:orientation= _"vertical"_


android:layout_width= _"match_parent"_
android:layout_height= _"match_parent"_ >

android:layout_height= _"wrap_content"_
android:layout_width= _"match_parent"_
android:id= _"@+id/tableLayout1"_ >

android:id= _"@+id/tableRow1"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_ >

android:text= _"Button"_
android:id= _"@+id/button1"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_ >

android:text= _"Button"_
android:id= _"@+id/button2"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_ >

android:text= _"Button"_
android:id= _"@+id/button3"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_ >

android:id= _"@+id/tableRow2"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_ >

android:text= _"Button"_
android:id= _"@+id/button4"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_ >

android:text= _"Margin"_
android:id= _"@+id/button5"_
android:layout_width= _"wrap_content"_


android:layout_height= _"wrap_content"_ >

android:text= _"Button"_
android:id= _"@+id/button6"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_ >

android:id= _"@+id/tableRow3"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_ >

android:text= _"Button"_
android:id= _"@+id/button7"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_ >

android:text= _"Button"_
android:id= _"@+id/button8"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_ >

android:text= _"Button"_
android:id= _"@+id/button9"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_ >

```
И на кнопке в центре будем экспериментировать.
```

**margin** = 50 dp
Вокруг кнопки со всех сторон образовался отступ = 50 dp.

**margin left** = 10 dp
**margin top** = 20 dp
Отступ слева и сверху.

**margin right** = 30 dp
**margin bottom** = 40 dp
Отступ справа и снизу.


**Стили**
Если кто использовал HTML, то наверняка слышали про каскадные
стили - CSS. Стили позволяют вам группировать атрибуты элементов
(кнопок, таблиц, параграфов и т.д.). Далее вы просто применяете к элементам
стили, и элемент рисуется с учетом всех атрибутов стиля. И нет
необходимости повторять несколько раз один и тот же код для элементов,
которые должны выглядеть одинаково. Особенно это удобно в случае
изменения атрибутов. Вы просто меняете один раз стиль и все элементы с
этим стилем меняются.
В Android тоже есть стили и они имеют точно такое же назначение.
Если у вас есть несколько элементов и вам надо, чтобы они выглядели
одинаково, то вы просто создаете один стиль и применяете его к нужным
элементам. В принципе, вы пока можете не заморачиваться этим и начать
использовать стили, когда наберетсь опыта.

**9.8 Работаем с элементами экрана из кода**
В этом уроке мы:

- научимся обращаться из кода к View-элементам на экране и менять их
свойства
Создадим проект:
**_Project name_** _: P0081_ViewById_
**_Build Target_** _: Android 2.3.3_


**_Application name_** _: ViewById_
**_Package name_** _: ru.startandroid.develop.viewbyid_
**_Create Activity_** _: MainActivity_

Чтобы обратиться к элементу экрана из кода, нам нужен его **ID**. Он
прописывается либо в **Properties** , либо в **layout-файлах** , как вам удобнее.
Для ID существует четкий формат - **@+id/name** , где **+** означает, что это
новый ресурс и он должен добавиться в **R.java** класс, если он там еще не
существует.
Давайте откроем **main.xml** , для **TextView** укажем **ID = @+id/myText** и
сохраним

Теперь откроем **R.java** и видим, что для класса **id** появилась
константа **myText**. Т.е. чтобы к ней обратиться, надо написать **R.id.myText**.


Она связана с элементом TextView и мы можем ее использовать, чтобы
обратиться к элементу программно. Для этого нам понадобится
метод **findViewById**. Он по ID возвращает View. Давайте напишем вызов
этого метода. Напомню, что пока мы пишем наш код в методе **onCreate**. Это
метод, который вызывается при создании Activity. Если вдруг непонятно,
куда писать, можно подсмотреть в конец урока, там я выложил код.
Откроем MainActivity.java и после строки с вызовом
метода **setContentView** напишем:
View myTextView = findViewById(R.id.myText);
Если View подчеркнуто красным, то скорей всего этот класс не
добавлен в секцию **import**. Нажмите CTRL+SHIFT+O для автоматического
обновления импорта.
Теперь **myTextView** (типа View) – это наш TextView на экране. Но
тип **View** – это предок для TextView (и остальных View-элементов). И он нам
не подходит, если мы хотим проделывать операции соответствующие
TextView. Поэтому нам необходимо **преобразование** View в TextView.
Изменим наш код на следующий:
TextView myTextView = (TextView) findViewById(R.id.myText);
Теперь **myTextView** имеет тип **TextView** , а результат метода
findViewById мы преобразуем из View в TextView. Теперь мы можем
применять к myTextView **методы класса TextView**. Для примера возьмем
метод **setText**. Сейчас отображаемый текст = _Hello World, MainActivity!_. Мы
его программно поменяем на _New text in TextView_
myTextView.setText("New text in TextView");
Сохраняем, запускаем (CTRL+F11) и видим, что текст изменился


Добавим на экран кнопку (Button), Id = @+id/myBtn, текст оставим по
умолчанию. Сохраняем - CTRL+SHIFT+S (если не сохранить, то в R.java не
появится ID).
Пишем код:
Button myBtn = (Button) findViewById(R.id.myBtn);
Обратите внимание, что у меня совпадает имя объекта и ID

Они друг другу не мешают и так делать даже логичнее. Это остается на
ваше усмотрение. Так, кнопку мы нашли, теперь давайте изменим ее текст:
myBtn.setText("My button");
Запустим приложение. Текст на кнопке поменялся, на кнопку можно
понажимать, но ничего происходить не будет. Т.к. мы нигде не указывали,
что надо делать при нажатии. Этим займемся на следующем уроке. А пока
давайте сделаем кнопку неактивной.
myBtn.setEnabled( **false** );


Мы поменяли параметр **Enabled**. Теперь на кнопку нельзя нажать.
Сохраним, запустим и убедимся.

Добавим CheckBox, id = @+id/myChb. По умолчанию галочка не стоит.
Давайте поставим ее программно, для этого используется метод setChecked,
который меняет параметр Checked.
CheckBox myChb = (CheckBox) findViewById(R.id.myChb);
myChb.setChecked( **true** );
Запустив приложение видим, что код сработал.
Как видите – все несложно. Используем метод **findViewById** , чтобы
по **ID** получить объект соответствующий какому-либо **View-
элементу** (Button, TextView, CheckBox) и далее вызываем необходимые
методы объектов (setText, setEnabled, setChecked).
В итоге должен получиться такой код:
**package** ru.startandroid.develop.viewbyid;
**import** android.app.Activity;
**import** android.os.Bundle;


**import** android.widget.Button;
**import** android.widget.CheckBox;
**import** android.widget.TextView;

**public class** MainActivity **extends** Activity {
/** Called when the activity is first created. */
@Override
**public void** onCreate(Bundle savedInstanceState) {
**super** .onCreate(savedInstanceState);
setContentView(R.layout.main);

TextView myTextView = (TextView) findViewById(R.id.myText);
myTextView.setText("New text in TextView");

Button myBtn = (Button) findViewById(R.id.myBtn);
myBtn.setText("My button");
myBtn.setEnabled( **false** );

CheckBox myChb = (CheckBox) findViewById(R.id.myChb);
myChb.setChecked( **true** );
}
}


```
Лекция 9. Обработчики событий. Оптимизация обработчиков
```
```
Обработчики событий на примере Button
```
В этом уроке мы:

- научимся обрабатывать нажатие кнопки и узнаем, что такое обработчик
- научимся использовать один обработчик для нескольких View-элементов
- научим Activity выступать в качестве обработчика
Создадим проект:
**Project name** : P0091_OnClickButtons
**Build Target** : Android 2.3.3
**Application name** : OnClickButtons
**Package name** : ru.startandroid.develop.onclickbuttons
**Create Activity** : MainActivity
В layout-файл **main.xml** напишем следующее и сохраним:
<?xml version= _"1.0"_ encoding= _"utf-8"_ ?>
<LinearLayout
xmlns:android= _"http://schemas.android.com/apk/res/android"_
android:layout_width= _"match_parent"_
android:layout_height= _"match_parent"_
android:orientation= _"horizontal"_ >
<LinearLayout
android:id= _"@+id/linearLayout1"_
android:layout_width= _"match_parent"_
android:layout_height= _"match_parent"_
android:layout_margin= _"30dp"_
android:orientation= _"vertical"_ >
<TextView
android:id= _"@+id/tvOut"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:layout_gravity= _"center_horizontal"_
android:layout_marginBottom= _"50dp"_


android:text= _"TextView"_ >
</TextView>
<Button
android:id= _"@+id/btnOk"_
android:layout_width= _"100dp"_
android:layout_height= _"wrap_content"_
android:layout_gravity= _"center_horizontal"_
android:text= _"OK"_ >
</Button>
<Button
android:id= _"@+id/btnCancel"_
android:layout_width= _"100dp"_
android:layout_height= _"wrap_content"_
android:layout_gravity= _"center_horizontal"_
android:text= _"Cancel"_ >
</Button>
</LinearLayout>
</LinearLayout>
У нас есть TextView с текстом и две кнопки: OK и Cancel. Мы сделаем
так, чтобы по нажатию кнопки менялось содержимое TextView. По нажатию
кнопки OK – будем выводить текст: «Нажата кнопка ОК», по нажатию Cancel

- «Нажата кнопка Cancel».
    Открываем **MainActivity.java**. Описание объектов вынесем за пределы
метода **onCreate**. Это сделано для того, чтобы мы могли из любого метода
обращаться к ним. В onCreate мы эти объекты заполним с помощью уже
пройденного нами метода **findViewById**. В итоге должен получиться такой
код:
**public class** MainActivity **extends** Activity {

TextView tvOut;
Button btnOk;
Button btnCancel;

/** Called when the activity is first created. */


@Override
**public void** onCreate(Bundle savedInstanceState) {
**super** .onCreate(savedInstanceState);
setContentView(R.layout.main);

// найдем View-элементы
tvOut = (TextView) findViewById(R.id.tvOut);
btnOk = (Button) findViewById(R.id.btnOk);
btnCancel = (Button) findViewById(R.id.btnCancel);

}
}
Обновляем секцию import (CTRL+SHIFT+O). Объекты tvOut, btnOk и
btnCancel соответствуют View-элементам экрана и мы можем с ними
работать. Нам надо научить кнопку реагировать на нажатие. Для этого у
кнопки есть метод **setOnClickListener (View.OnClickListener l)**. На вход
подается объект с **интерфейсом View.OnClickListener**. Именно этому
объекту кнопка поручит обрабатывать нажатия. Давайте создадим такой
объект. Код продолжаем писать в onCreate:
OnClickListener oclBtnOk = **new** OnClickListener() {
@Override
**public void** onClick(View v) {
// TODO Auto-generated method stub

}
};
Android Studio подчеркивает OnClickListener красной линией


т.к. пока не знает его. Необходимо обновить секцию import. Жмем
CTRL+SHIFT+O, Android Studio показывает нам, что он знает два
интерфейса с именем onClickListener и предлагает выбрать. Нам нужен
View.OnClickListener, т.к. метод кнопки setOnClickListener принимает на
вход именно его.

Итак, мы создали объект oclBtnOk, который реализует интерфейс
View.OnClickListener. Объект содержит метод onClick – это как раз то, что
нам нужно. Именно этот метод будет вызван при нажатии кнопки. Мы
решили, что по нажатию будем выводить текст: «Нажата кнопка ОК» в
TextView (tvOut). Реализуем это.
В методе onClick пишем:
tvOut.setText("Нажата кнопка ОК");
Обработчик нажатия готов. Осталось «скормить» его кнопке с
помощью метода setOnClickListener.
btnOk.setOnClickListener(oclBtnOk);


В итоге должен получится такой код:
**public class** MainActivity **extends** Activity {

TextView tvOut;
Button btnOk;
Button btnCancel;

/** Called when the activity is first created. */
@Override
**public void** onCreate(Bundle savedInstanceState) {
**super** .onCreate(savedInstanceState);
setContentView(R.layout.main);

// найдем View-элементы
tvOut = (TextView) findViewById(R.id.tvOut);
btnOk = (Button) findViewById(R.id.btnOk);
btnCancel = (Button) findViewById(R.id.btnCancel);

// создаем обработчик нажатия
OnClickListener oclBtnOk = **new** OnClickListener() {
@Override
**public void** onClick(View v) {
// Меняем текст в TextView (tvOut)
tvOut.setText("Нажата кнопка ОК");
}
};

// присвоим обработчик кнопке OK (btnOk)
btnOk.setOnClickListener(oclBtnOk);
}
}


Все сохраняем и запускаем. Жмем на кнопку ОК и видим. Что текст
изменился

Нажатие на Cancel пока ни к чему не приводит, т.к. для нее мы
обработчик не создали и не присвоили. Давайте сделаем это аналогично, как
для кнопки OK. Сначала мы создаем обработчик:
OnClickListener oclBtnCancel = **new** OnClickListener() {
@Override
**public void** onClick(View v) {
// Меняем текст в TextView (tvOut)
tvOut.setText("Нажата кнопка Cancel");
}
};
Потом присваиваем его кнопке:
btnCancel.setOnClickListener(oclBtnCancel);
Сохраняем, запускаем, проверяем. Обе кнопки теперь умеют
обрабатывать нажатия.


Давайте еще раз проговорим механизм обработки событий на примере
нажатия кнопки. Сама кнопка обрабатывать нажатия не умеет, ей нужен
обработчик (его также называют слушателем - listener), который
присваивается с помощью метода setOnClickListener. Когда на кнопку
нажимают, обработчик реагирует и выполняет код из метода onClick. Это
можно изобразить так:

Соответственно для реализации необходимо выполнить следующие
шаги:

- создаем обработчик
- заполняем метод onClick
- присваиваем обработчик кнопке
и система обработки событий готова.

```
Оптимизируем реализацию обработчиков
```
Создадим проект:
**Project name** : P0101_Listener
**Build Target** : Android 2.3.3
**Application name** : Listener
**Package name** : ru.startandroid.develop.listener
**Create Activity** : MainActivity


Будем работать с теми же View, что и в предыдущем уроке. Код
для **main.xml** :
<?xml version= _"1.0"_ encoding= _"utf-8"_ ?>
<LinearLayout
xmlns:android= _"http://schemas.android.com/apk/res/android"_
android:layout_height= _"match_parent"_
android:layout_width= _"match_parent"_
android:orientation= _"horizontal"_ >
<LinearLayout
android:id= _"@+id/linearLayout1"_
android:layout_height= _"match_parent"_
android:orientation= _"vertical"_
android:layout_width= _"match_parent"_
android:layout_margin= _"30dp"_ >
<TextView
android:layout_width= _"wrap_content"_
android:text= _"TextView"_
android:layout_height= _"wrap_content"_
android:id= _"@+id/tvOut"_
android:layout_gravity= _"center_horizontal"_
android:layout_marginBottom= _"50dp"_ >
</TextView>
<Button
android:layout_height= _"wrap_content"_
android:layout_gravity= _"center_horizontal"_
android:id= _"@+id/btnOk"_
android:text= _"OK"_
android:layout_width= _"100dp"_ >
</Button>
<Button
android:layout_height= _"wrap_content"_
android:layout_gravity= _"center_horizontal"_
android:id= _"@+id/btnCancel"_
android:text= _"Cancel"_
android:layout_width= _"100dp"_ >


</Button>
</LinearLayout>
</LinearLayout>

**Один обработчик для двух кнопок**
Итак, у нас есть TextView с текстом и две кнопки. Как и на прошлом
уроке, мы сделаем так, чтобы по нажатию кнопки менялось содержимое
TextView. По нажатию кнопки OK – будем выводить текст: «Нажата кнопка
ОК», по нажатию Cancel – «Нажата кнопка Cancel». Но сейчас мы сделаем
это с помощью **одного обработчика** , который будет обрабатывать
нажатия **для обеих кнопок**.
Напомню механизм обработки событий на примере нажатия кнопки.
Сама кнопка обрабатывать нажатия не умеет, ей нужен обработчик (listener),
который присваивается с помощью метода setOnClickListener. Когда на
кнопку нажимают, обработчик реагирует и выполняет код из метода onClick.
Соответственно для реализации необходимо выполнить следующие
шаги:

- создаем обработчик
- заполняем метод onClick
- присваиваем обработчик кнопке
В нашем случае мы будем присваивать один обработчик обеим
кнопкам, а внутри обработчика надо будет определять, какая именно кнопка
была нажата.
Подготовим объекты и создадим обработчик:
**public class** MainActivity **extends** Activity {

TextView tvOut;
Button btnOk;
Button btnCancel;

/** Called when the activity is first created. */
@Override


**public void** onCreate(Bundle savedInstanceState) {
**super** .onCreate(savedInstanceState);
setContentView(R.layout.main);

// найдем View-элементы
tvOut = (TextView) findViewById(R.id.tvOut);
btnOk = (Button) findViewById(R.id.btnOk);
btnCancel = (Button) findViewById(R.id.btnCancel);

// создание обработчика
OnClickListener oclBtn = **new** OnClickListener() {
@Override
**public void** onClick(View v) {
// TODO Auto-generated method stub

}
};

}
}
Давайте заполнять метод onClick. На вход ему подается объект
класса **View** , это как раз то, что нам нужно. Это View на которой произошло
нажатие и которая вызвала обработчик. Т.е. в нашем случае это будет либо
кнопка OK либо Cancel. Нам осталось узнать **ID** этой **View** и сравнить его с
нашими **R.id.btnOk** и **R.id.btnCancel** , чтобы определить какая именно это
кнопка. Чтобы получить ID какой-либо View, используется метод **getId**. Для
перебора результатов используем java-оператор **switch**.
Реализация метода onClick:
**public void** onClick(View v) {
// по id определеяем кнопку, вызвавшую этот обработчик
**switch** (v.getId()) {
**case** R.id.btnOk:
// кнопка ОК
tvOut.setText("Нажата кнопка ОК");


**break** ;
**case** R.id.btnCancel:
// кнопка Cancel
tvOut.setText("Нажата кнопка Cancel");
**break** ;
}
}
Если сейчас запустить приложение и проверить, то ничего не
произойдет. Обработчик то мы создали, но не присвоили его кнопкам. Обеим
кнопкам присваиваем один и тот же обработчик:
btnOk.setOnClickListener(oclBtn);
btnCancel.setOnClickListener(oclBtn);
Вот теперь можем запускать и проверять, все должно работать.
Как вы понимаете, **один обработчик** может быть присвоен не двум,
а **любому количеству** кнопок. И не только кнопкам. У остальных View-
элементов тоже есть различные события, которые нуждаются в
обработчиках. В дальнейшем мы еще будем с ними работать. А сейчас важно
понять схему, как происходит обработка событий.
Отличие способа реализации на этом уроке от прошлого урока в том,
что сейчас мы создали **один объект-обработчик для обеих кнопок** , а на
прошлом уроке - **два объекта, по одному каждой кнопке**. Есть правило –
чем меньше объектов вы создаете, тем лучше, т.к. под каждый объект
выделяется память, а это достаточно ограниченный ресурс, особенно для
телефонов. Поэтому создавать один обработчик для нескольких View это
правильнее с точки зрения оптимизации. К тому же кода становится меньше
и читать его удобнее.
Есть еще один способ создания обработчика, который вовсе не
потребует создания объектов. Будет использоваться уже созданный объект –
Activity.

```
Activity, как обработчик
```

Кнопка присваивает себе обработчика с помощью
метода **setOnClickListener (View.OnClickListener l)**. Т.е. подойдет любой
объект с **интерфейсом View.OnClickListener**. Почему бы классу Activity не
быть таким объектом? Мы просто укажем, что Activity-класс реализует
интерфейс View.OnClickListener и заполним метод onCreate.
Создадим для этого новый проект:
**Project name** : P0102_ActivityListener
**Build Target** : Android 2.3.3
**Application name** : ActivityListener
**Package name** : ru.startandroid.develop.activitylistener
**Create Activity** : MainActivity
Экран снова возьмем тот же самый:
<?xml version= _"1.0"_ encoding= _"utf-8"_ ?>
<LinearLayout
xmlns:android= _"http://schemas.android.com/apk/res/android"_
android:layout_height= _"match_parent"_
android:layout_width= _"match_parent"_
android:orientation= _"horizontal"_ >
<LinearLayout
android:id= _"@+id/linearLayout1"_
android:layout_height= _"match_parent"_
android:orientation= _"vertical"_
android:layout_width= _"match_parent"_
android:layout_margin= _"30dp"_ >
<TextView
android:layout_width= _"wrap_content"_
android:text= _"TextView"_
android:layout_height= _"wrap_content"_
android:id= _"@+id/tvOut"_
android:layout_gravity= _"center_horizontal"_
android:layout_marginBottom= _"50dp"_ >
</TextView>
<Button


android:layout_height= _"wrap_content"_
android:layout_gravity= _"center_horizontal"_
android:id= _"@+id/btnOk"_
android:text= _"OK"_
android:layout_width= _"100dp"_ >
</Button>
<Button
android:layout_height= _"wrap_content"_
android:layout_gravity= _"center_horizontal"_
android:id= _"@+id/btnCancel"_
android:text= _"Cancel"_
android:layout_width= _"100dp"_ >
</Button>
</LinearLayout>
</LinearLayout>

Подготовим объекты и добавим реализацию интерфейса (implements
onClickListener)
**public class** MainActivity **extends** Activity **implements** OnClickListener {

TextView tvOut;
Button btnOk;
Button btnCancel;

/** Called when the activity is first created. */
@Override
**public void** onCreate(Bundle savedInstanceState) {
**super** .onCreate(savedInstanceState);
setContentView(R.layout.main);

// найдем View-элементы
tvOut = (TextView) findViewById(R.id.tvOut);
btnOk = (Button) findViewById(R.id.btnOk);
btnCancel = (Button) findViewById(R.id.btnCancel);


}
}
OnClickListener подчеркнут красным, т.к. его нет в импорте. Поэтому
CTRL+SHIFT+O и выбираем View.OnClickListener.

Теперь AS ругается на класс MainActivity. Это происходит потому, что для
класса **прописан интерфейс** , но **нет реализации методов** этого интерфейса.
Исправим это с помощью AS Наведите курсор на **MainAcivity** и
выберите **Add unimplemented methods**

Android Studio добавит знакомый нам метод **onClick**. Только теперь
этот метод будет реализован в Activity, а не в отдельном объекте-
обработчике. Соответственно Activity и будет выступать обработчиком.
Заполним метод точно так же как и раньше. Ничего не изменилось. Ему
на вход так же подается View (на которой произошло событие), по Id мы
определим, какая именно эта View и выполним соответствующие действия:


**public void** onClick(View v) {
// по id определеяем кнопку, вызвавшую этот обработчик
**switch** (v.getId()) {
**case** R.id.btnOk:
// кнопка ОК
tvOut.setText("Нажата кнопка ОК");
**break** ;
**case** R.id.btnCancel:
// кнопка Cancel
tvOut.setText("Нажата кнопка Cancel");
**break** ;
}
}
Осталось в методе onCreate присвоить обработчик кнопкам. Это будет
объект this, т.е. текущий объект MainActivity.
btnOk.setOnClickListener( **this** );
btnCancel.setOnClickListener( **this** );
При такой реализации мы не создали ни одного лишнего объекта
(Activity создается в любом случае) и затраты памяти минимальны, это
рекомендуемый метод. Но, возможно, такой способ покажется сложным и
непонятным, особенно если мало опыта в объектно-ориентированном
программировании. В таком случае используйте ту реализацию, которая вам
понятна и удобна. А со временем и опытом понимание обязательно придет.
Полный код:
**public class** MainActivity **extends** Activity **implements** OnClickListener {

TextView tvOut;
Button btnOk;
Button btnCancel;

/** Called when the activity is first created. */
@Override
**public void** onCreate(Bundle savedInstanceState) {
**super** .onCreate(savedInstanceState);


setContentView(R.layout.main);

// найдем View-элементы
tvOut = (TextView) findViewById(R.id.tvOut);
btnOk = (Button) findViewById(R.id.btnOk);
btnCancel = (Button) findViewById(R.id.btnCancel);

// присваиваем обработчик кнопкам
btnOk.setOnClickListener( **this** );
btnCancel.setOnClickListener( **this** );
}

@Override
**public void** onClick(View v) {
// по id определеяем кнопку, вызвавшую этот обработчик
**switch** (v.getId()) {
**case** R.id.btnOk:
// кнопка ОК
tvOut.setText("Нажата кнопка ОК");
**break** ;
**case** R.id.btnCancel:
// кнопка Cancel
tvOut.setText("Нажата кнопка Cancel");
**break** ;
}
}

}

**Самая простая реализация обработчика**
Есть еще один способ реализации. В layout-файле (main.xml) при
описании кнопки пишем:
<?xml version= _"1.0"_ encoding= _"utf-8"_ ?>
<Button


android:id= _"@+id/btnStart"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:onClick= _"onClickStart"_
android:text= _"start"_ >
</Button>
Т.е. используем атрибут **onClick**. В нем указываем имя метода из
Activity. Этот метод и сработает при нажатии на кнопку.
Далее, добавляем этот метод в Activity (MainActivity.java). Требования
к методу: public, void и на вход принимает View:
**public void** onClickStart(View v) {
// действия при нажати на кнопку
}
В методе прописываете необходимые вам действия, и они будут
выполнены при нажатии кнопки.


```
Лекция 10. Использование ресурсов приложения. Логи и всплывающие
сообщения
```
```
В этом уроке мы:
```
- узнаем, зачем нужна папка res/values, что в ней можно хранить и как
использовать
- рассмотрим логи приложения и всплывающие сообщения

**Использование ресурсов приложения**
В **подпапках** res хранятся различные **ресурсы** приложения. Мы уже
отлично знаем про **layout-файлы** в папке **res/layout**. Я упоминал про
папку **res/drawable** с density-суффиксами – в ней хранятся **картинки**. Теперь
обратим внимание на папку **res/values**. Она предназначена для хранения
ресурсов (констант) **различных типов**. Мы рассмотрим типы **String** и **Color**.
Создадим проект:
**Project name** : P0111_ResValues
**Build Target** : Android 2.3.3
**Application name** : ResValues
**Package name** : ru.startandroid.develop.resvalues
**Create Activity** : MainActivity
Откроем файл **res/values/strings.xml**


Мы видим два элемента типа String:
**hello** – по умолчанию он использован в свойстве Text в TextView в
main.xml. И соответственно TextView отображает значение этого элемента.

**app_name** – по умолчанию используется как заголовок для приложения
и Activity. Это указывается в манифест-файле, который мы еще не разбирали.
На эти элементы можно кликнуть и увидеть справа, что они собой
представляют: **имя** (Name) и **значение** (Value)


**Name** – это **ID**. Оно должно быть уникальным, и для него
в **R.java** создается константа, чтобы мы могли иметь доступ к этому String-
элементу.

```
Если мы посмотрим XML-содержимое файла strings.xml (вкладка снизу
```
- аналогично как для main.xml), то видим, что там все прозрачно и просто.
Попробуем и мы использовать ресурсы.
    Для начала создадим такой экран в **main.xml** :
    version= _"1.0"_ encoding= _"utf-8"_ ?>

xmlns:android= _"http://schemas.android.com/apk/res/android"_


android:layout_height= _"match_parent"_
android:layout_width= _"match_parent"_
android:orientation= _"vertical"_ >

android:layout_width= _"match_parent"_
android:id= _"@+id/llTop"_
android:orientation= _"vertical"_
android:layout_weight= _"1"_
android:layout_height= _"match_parent"_ >

android:text= _"TextView"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:layout_gravity= _"center_horizontal"_
android:id= _"@+id/tvTop"_
android:layout_marginTop= _"30dp"_ >

android:text= _"Button"_
android:layout_height= _"wrap_content"_
android:layout_gravity= _"center_horizontal"_
android:id= _"@+id/btnTop"_
android:layout_width= _"wrap_content"_ >

android:layout_width= _"match_parent"_
android:id= _"@+id/llBottom"_
android:orientation= _"vertical"_
android:layout_weight= _"1"_
android:layout_height= _"match_parent"_ >

android:text= _"TextView"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_


android:layout_gravity= _"center_horizontal"_
android:id= _"@+id/tvBottom"_
android:layout_marginTop= _"30dp"_ >

android:text= _"Button"_
android:layout_width= _"wrap_content"_
android:layout_height= _"wrap_content"_
android:layout_gravity= _"center_horizontal"_
android:id= _"@+id/btnBottom"_ >
Экран разделен на две одинаковые половины, содержащие LinearLayout,
Button и TextView. Для **LinearLayout** мы укажем **фоновый цвет** , а
для **TextView** и **Button** – изменим **текст**. Реализуем это с помощью ресурсов.
Причем View-элементы **верхней** части мы будем настраивать вручную
через **properties** , а **нижнюю** часть попробуем настроить **программно**.
Давайте создадим свой файл с ресурсами в папке values, название пусть
будет myres.


После создания открылся редактор файла. Добавлять элемент просто –
жмем кнопку **Add** и выбираем **тип** , а справа пишем **имя** и **значение**.
Создадим 4 String-элемента и 2 Color-элемента:
version= _"1.0"_ encoding= _"utf-8"_ ?>
>
name= _"tvTopText"_ >Верхний текст
name= _"btnTopText"_ >Верхняя кнопка
name= _"tvBottomText"_ >Нижний текст
name= _"btnBottomText"_ >Нижняя кнопка


name= _"llTopColor"_ >#336699
name= _"llBottomColor"_ >#339966
Для практики можете создать вручную, а можете просто вставить этот
текст в содержимое myres.xml. Не забудьте сохранить. Заглянем в R.java,
убедимся, что здесь все появилось:

Ок, ресурсы созданы, настроим View-элементы на их использование.
Сначала верхние:
**llTop** – в Properties находим свойство **Background** , жмем кнопку
выбора (три точки), в ветке **Color** выделяем **llTopColor** и жмем **OK**


**tvTop** – для свойства Text откройте окно выбора и найдите
там **tvTopText**.
**btnTop** - для свойства Text откройте окно выбора и найдите
там **btnTopText**.
Цвет верхней части изменился и тексты поменялись на те, что мы
указывали в myres.xml.
Чтобы изменить нижнюю часть, будем кодить. Сначала находим
элементы, потом присваиваем им значения.
**public class** MainActivity **extends** Activity {
/** Called when the activity is first created. */
@Override
**public void** onCreate(Bundle savedInstanceState) {
**super** .onCreate(savedInstanceState);
setContentView(R.layout.main);
LinearLayout llBottom = (LinearLayout) findViewById(R.id.llBottom);
TextView tvBottom = (TextView) findViewById(R.id.tvBottom);
Button btnBottom = (Button) findViewById(R.id.btnBottom);
llBottom.setBackgroundResource(R.color.llBottomColor);
tvBottom.setText(R.string.tvBottomText);
btnBottom.setText(R.string.btnBottomText);
}
}
Обратите внимание на то, что для смены текста используется
метод **setText**. Только это не тот же setText, что мы использовали, когда


задавали текст напрямую. Этот **на вход** принимает **ID** и мы используем
R.java, который хранит ID всех наших ресурсов. Т.е. методы называются
одинаково, но на вход принимают разные параметры. Это **нормальное
явление** в Java.
Сохраняем, запускаем и проверяем. Теперь тексты и цвета взяты из
файла ресурсов. Вы можете изменить содержимое myres.xml (например текст
для верхней кнопки), сохранить, запустить приложение и увидите изменения.
Иногда необходимо в коде получить не ID ресурса, а его значение. Это
делается следующим образом:
getResources().getString(R.string.tvBottomText);
Выражение вернет текст «Нижний текст», соответствующий String-
ресурсу с name = **tvBottomText**.
Напоследок скажу пару слов об организации файлов для хранения
ресурсов. Мы сейчас создали String и Color ресурсы **в одном
файле** myres.xml, но рекомендуется их разделять **по разным
файлам** (например strings.xml, colors.xml ...), и в дальнейшем я буду
следовать этой рекомендации. Для этого есть причины, позже мы в этом
убедимся.
Имена ресурсов сквозные для всех файлов в папке res/values. Т.е. вы не
можете в разных файлах создать ресурс с одним именем и типом.
Имена файлов ресурсов могут быть произвольными и файлов можно
создавать сколько угодно. В R.java попадут все ресурсы из этих файлов.

```
Логи и всплывающие сообщения
```
Создадим проект:
**Project name** : P0121_LogAndMess
**Build Target** : Android 2.3.3
**Application name** : LogAndMess
**Package name** : ru.startandroid.develop.logandmess
**Create Activity** : MainActivity


Создадим в **main.xml** экран, знакомый нам по прошлым урокам про
обработчики:
<?xml version= _"1.0"_ encoding= _"utf-8"_ ?>
<LinearLayout
xmlns:android= _"http://schemas.android.com/apk/res/android"_
android:layout_height= _"match_parent"_
android:layout_width= _"match_parent"_
android:orientation= _"horizontal"_ >
<LinearLayout
android:id= _"@+id/linearLayout1"_
android:layout_height= _"match_parent"_
android:orientation= _"vertical"_
android:layout_width= _"match_parent"_
android:layout_margin= _"30dp"_ >
<TextView
android:layout_width= _"wrap_content"_
android:text= _"TextView"_
android:layout_height= _"wrap_content"_
android:id= _"@+id/tvOut"_
android:layout_gravity= _"center_horizontal"_
android:layout_marginBottom= _"50dp"_ >
</TextView>
<Button
android:layout_height= _"wrap_content"_
android:layout_gravity= _"center_horizontal"_
android:id= _"@+id/btnOk"_
android:text= _"OK"_
android:layout_width= _"100dp"_ >
</Button>
<Button
android:layout_height= _"wrap_content"_
android:layout_gravity= _"center_horizontal"_


android:id= _"@+id/btnCancel"_
android:text= _"Cancel"_
android:layout_width= _"100dp"_ >
</Button>
</LinearLayout>
</LinearLayout>

Алгоритм приложения будет тот же. По нажатию кнопок меняется
текст. Обработчик - Activity.
**public class** MainActivity **extends** Activity **implements** OnClickListener {

TextView tvOut;
Button btnOk;
Button btnCancel;

/** Called when the activity is first created. */
@Override
**public void** onCreate(Bundle savedInstanceState) {
**super** .onCreate(savedInstanceState);
setContentView(R.layout.main);

// найдем View-элементы
tvOut = (TextView) findViewById(R.id.tvOut);
btnOk = (Button) findViewById(R.id.btnOk);
btnCancel = (Button) findViewById(R.id.btnCancel);

// присваиваем обработчик кнопкам
btnOk.setOnClickListener( **this** );
btnCancel.setOnClickListener( **this** );
}

@Override
**public void** onClick(View v) {
// по id определяем кнопку, вызвавшую этот обработчик
**switch** (v.getId()) {


**case** R.id.btnOk:
// кнопка ОК
tvOut.setText("Нажата кнопка ОК");
**break** ;
**case** R.id.btnCancel:
// кнопка Cancel
tvOut.setText("Нажата кнопка Cancel");
**break** ;
}
}

}
Сохраним, запустим. Убедимся, что все работает.

**Логи приложения**
Когда вы тестируете работу приложения, вы можете
видеть **логи** работы. Они отображаются в окне **LogCat**. Чтобы отобразить
окно откройте меню **Window > Show View > Other** ... В появившемся окне
выберите **Android > LogCat**


```
Должна появится вкладка LogCat
```
Рассмотрим эту вкладку подробней. **Логи** имеют разные уровни
важности: **ERROR** , **WARN** , **INFO** , **DEBUG** , **VERBOSE** (по
убыванию). Кнопки V D I W E (в кружках) – это фильтры и соответствуют
типам логов. Опробуйте их и обратите внимание, что фильтр показывает
логи не только своего уровня, но и уровней более высокой важности. Также
вы можете создавать, редактировать и удалять свои фильтры – это мы
рассмотрим чуть дальше.
Давайте смотреть, как самим писать логи. Делается это совсем
несложно с помощью класса **Log** и его методов Log.v() Log.d() Log.i() Log.w()
and Log.e(). Названия методов соответствуют уровню логов, которые они
запишут.
Изменим код **MainActivity.java**. Возьмем все каменты из кода и
добавим в DEBUG-логи с помощью метода Log.d. Метод требует на
вход **тэг** и **текст** сообщения. Тэг – это что-то типа метки, чтобы легче было
потом в куче системных логов найти именно наше сообщение. Добавим
описание тега (TAG) и запишем все тексты каментов в лог.
**public class** MainActivity **extends** Activity **implements** OnClickListener {

TextView tvOut;
Button btnOk;
Button btnCancel;

**private static final** String TAG = "myLogs";


/** Called when the activity is first created. */
@Override
**public void** onCreate(Bundle savedInstanceState) {
**super** .onCreate(savedInstanceState);
setContentView(R.layout.main);

// найдем View-элементы
Log.d(TAG, "найдем View-элементы");
tvOut = (TextView) findViewById(R.id.tvOut);
btnOk = (Button) findViewById(R.id.btnOk);
btnCancel = (Button) findViewById(R.id.btnCancel);

// присваиваем обработчик кнопкам
Log.d(TAG, "присваиваем обработчик кнопкам");
btnOk.setOnClickListener( **this** );
btnCancel.setOnClickListener( **this** );
}
@Override
**public void** onClick(View v) {
// по id определяем кнопку, вызвавшую этот обработчик
Log.d(TAG, "по id определяем кнопку, вызвавшую этот обработчик");
**switch** (v.getId()) {
**case** R.id.btnOk:
// кнопка ОК
Log.d(TAG, "кнопка ОК");
tvOut.setText("Нажата кнопка ОК");
**break** ;
**case** R.id.btnCancel:
// кнопка Cancel
Log.d(TAG, "кнопка Cancel");
tvOut.setText("Нажата кнопка Cancel");
**break** ;
}
}
}


Eclipse ругнется, что не знает класс Log. Обновите импорт
(CTRL+SHIFT+O) и, если спросит, выберите **android.util.Log**. Запустим
приложение, понажимаем кнопки и посмотрим логи

Видно, что все отлично записалось. Чтобы сделать просмотр удобней,
создадим свой фильтр. Жмем значок **+**

**Имя фильтра** произвольное, например, « **My logs** ». **Log Tag** – это как
раз значение константы TAG, которая описана в нашем коде и
использовалась в методе Log.d, т.е. - " **myLogs** ". **Pid** оставляем **пустым** , это id
процесса. **Уровень** поставим **Debug**


и жмем OK. Появилась новая вкладка My logs, на которой
отображаются логи, соответствующие только что созданному фильтру.
Мы помещали в лог текст, но разумеется, вы можете писать, например,
значения интересующих вас переменных (приведенные к типу String).
Иногда бывает, что логи не отображаются во вкладке LogCat, хотя
AVD запущен, приложение работает без проблем. В таком случае должно
помочь следующее: в Eclipse идем в меню Window > Open Perspective > Other
> DDMS. Откроется немного другой набор окон чем обычно. Там найдите
вкладку Devices и в ней должно быть видно ваше AVD-устройство, кликните
на него и логи должны появиться. Чтобы вернуться в разработку: Window >
Open Perspective > Java.

**Всплывающие сообщения**
Приложение может показывать **всплывающие сообщения** с помощью
класса **Toast**. Давайте подредактируем метод onClick. Сделаем так, чтобы
всплывало сообщение о том, какая кнопка была нажата.
**public void** onClick(View v) {
// по id определяем кнопку, вызвавшую этот обработчик
Log.d(TAG, "по id определяем кнопку, вызвавшую этот обработчик");
**switch** (v.getId()) {
**case** R.id.btnOk:
// кнопка ОК


Log.d(TAG, "кнопка ОК");
tvOut.setText("Нажата кнопка ОК");
Toast.makeText(this, "Нажата кнопка ОК", Toast.LENGTH_LONG).show();
**break** ;
**case** R.id.btnCancel:
// кнопка Cancel
Log.d(TAG, "кнопка Cancel");
tvOut.setText("Нажата кнопка Cancel");
Toast.makeText(this, "Нажата кнопка Cancel", Toast.LENGTH_LONG).show();
**break** ;
}
}
Разберем синтаксис вызова. Статический метод **makeText** создает
View-элемент **Toast**. Параметры метода:

- **context** – пока не будем вдаваться в подробности, что это такое и
используем текущую Activity, т.е. this.
- **text** – текст, который надо показать
- **duration** – продолжительность показа ( **Toast.LENGTH_LONG** -
длинная, **Toast.LENGTH_SHORT** - короткая)
Toast создан и чтобы он отобразился на экране, вызывается
метод **show** (). Сохраняем, запускаем, проверяем.


Если у вас есть Андроид-смартфон, я думаю вы уже видели подобные
сообщения. Теперь вы знаете, как это делается )


```
Тема. Создание простого меню
```
Цель:

- создаем пункты меню

Что такое меню, думаю, нет смысла рассказывать. Оно отображается при
нажатии кнопки Menu. Давайте создадим свое.

Кнопки меню обычно уже нет на современных устройствах. Меню переехало
в ActionBar.

Откроем MainActivity.java. За создание меню отвечает
метод onCreateOptionsMenu. На вход ему подается объект типа Menu, в
который мы и будем добавлять свои пункты.

Добавьте в Activity этот метод:
public boolean onCreateOptionsMenu(Menu menu) {

// TODO Auto-generated method stub

menu.add("menu1");
menu.add("menu2");

menu.add("menu3");

menu.add("menu4");


return super.onCreateOptionsMenu(menu);

}

Пункты меню добавляются методом add. На вход методу
подается текст пункта меню. Добавим 4 пункта.
Метод onCreateOptionsMenu должен вернуть результат типа boolean. True –
меню показывать, False – не показывать. Т.е. можно было бы накодить
проверку какого-либо условия, и по итогам этой проверки не показывать
меню передавая False. Пока нам это не нужно, поэтому поручаем этот выбор
методу суперкласса, по умолчанию он возвращает True.

Сохраним все, запустим приложение и нажмем кнопку меню на эмуляторе.

Появилось 4 пункта меню. Нажатие на них ни к чему не приводит, т.к. не
реализован обработчик. Обработчиком является Activity, а метод
зовется onOptionsItemSelected. На вход ему передается пункт меню, который
был нажат – MenuItem. Определить, какое именно меню было нажато можно
по методу getTitle. Давайте выводить всплывающее сообщение с текстом
нажатого пункта меню. На выходе метода надо возвращать boolean. И мы
снова предоставляем это суперклассу.

public boolean onOptionsItemSelected(MenuItem item) {

// TODO Auto-generated method stub
Toast.makeText(this, item.getTitle(), Toast.LENGTH_SHORT).show();

return super.onOptionsItemSelected(item);


## }

Полный код:
public class MainActivity extends Activity {

/** Called when the activity is first created. */

@Override
public void onCreate(Bundle savedInstanceState) {

super.onCreate(savedInstanceState);

setContentView(R.layout.main);

}

@Override

public boolean onCreateOptionsMenu(Menu menu) {
// TODO Auto-generated method stub

menu.add("menu1");
menu.add("menu2");

menu.add("menu3");

menu.add("menu4");

return super.onCreateOptionsMenu(menu);

}

@Override

public boolean onOptionsItemSelected(MenuItem item) {

// TODO Auto-generated method stub

Toast.makeText(this, item.getTitle(), Toast.LENGTH_SHORT).show();
return super.onOptionsItemSelected(item);

}


## }

Определять нажатый пункт меню по тексту – это не самый лучший вариант.
Далее будем делать это по ID. Но для этого надо немного по другому
создавать меню.

```
Тема. Меню, группы, порядок. MenuInflater и xml-меню
```
Цель:

- создаем пункты меню c ID
- группируем и сортируем пункты меню
На прошлом уроке мы рассмотрели простейший способ создания меню
методом add(CharSequence title), на вход мы подавали только текст.
Рассмотрим другую реализацию этого метода - add(int groupId, int itemId, int
order, CharSequence title). У этого метода 4 параметра на вход:
- groupId - идентификатор группы, частью которой является пункт меню
- itemId - ID пункта меню
- order - для задания последовательности показа пунктов меню
- title - текст, который будет отображен

Чтоб показать как используются все эти параметры, создадим приложение.
На экране будет TextView и CheckBox:

- TextView будет отображать какой пункт меню был выбран
- CheckBox будет определять показывать обычное меню или расширенное.
Это будет реализовано с помощью групп меню.

Сразу уточню, понятия "обычное" и "расширенное" - это не Андроид-
понятия, а просто мои названия. Т.е. когда запущено приложение и
пользователь жмет кнопку меню, он видит "обычное" меню. Если же он
включит CheckBox, то будет отображаться "расширенное" меню, в котором
больше пунктов.

Откроем main.xml, присвоим ID существующему TextView, сотрем его текст
и создадим CheckBox. Код:

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout


xmlns:android="http://schemas.android.com/apk/res/android"

android:orientation="vertical"
android:layout_width="fill_parent"

android:layout_height="fill_parent">

<CheckBox
android:layout_width="wrap_content"

android:layout_height="wrap_content"

android:id="@+id/chbExtMenu"

android:text="расширенное меню">
</CheckBox>

<TextView

android:layout_width="fill_parent"
android:layout_height="wrap_content"

android:id="@+id/textView">

</TextView>
</LinearLayout>

Открываем MainActivity.java и класс MainActivity заполняем следующим
кодом:
public class MainActivity extends Activity {

// Элементы экрана
TextView tv;

CheckBox chb;

/** Called when the activity is first created. */

@Override

public void onCreate(Bundle savedInstanceState) {


super.onCreate(savedInstanceState);

setContentView(R.layout.main);
// находим элементы

tv = (TextView) findViewById(R.id.textView);

chb = (CheckBox) findViewById(R.id.chbExtMenu);

## }

// создание меню
@Override

public boolean onCreateOptionsMenu(Menu menu) {

// TODO Auto-generated method stub
// добавляем пункты меню

menu.add(0, 1, 0, "add");

menu.add(0, 2, 0, "edit");
menu.add(0, 3, 3, "delete");

menu.add(1, 4, 1, "copy");

menu.add(1, 5, 2, "paste");

menu.add(1, 6, 4, "exit");

return super.onCreateOptionsMenu(menu);

}

// обновление меню

@Override

public boolean onPrepareOptionsMenu(Menu menu) {
// TODO Auto-generated method stub

// пункты меню с ID группы = 1 видны, если в CheckBox стоит галка


menu.setGroupVisible(1, chb.isChecked());

return super.onPrepareOptionsMenu(menu);
}

// обработка нажатий
@Override

public boolean onOptionsItemSelected(MenuItem item) {

// TODO Auto-generated method stub

StringBuilder sb = new StringBuilder();

// Выведем в TextView информацию о нажатом пункте меню

sb.append("Item Menu");
sb.append("\r\n groupId: " + String.valueOf(item.getGroupId()));

sb.append("\r\n itemId: " + String.valueOf(item.getItemId()));

sb.append("\r\n order: " + String.valueOf(item.getOrder()));
sb.append("\r\n title: " + item.getTitle());

tv.setText(sb.toString());

return super.onOptionsItemSelected(item);
}

}

Давайте разбирать написанное. Мы используем следующие методы:

onCreateOptionsMenu - вызывается только при первом показе меню. Создает
меню и более не используется. Здесь мы добавляем к меню пункты.

onPrepareOptionsMenu - вызывается каждый раз перед отображением меню.
Здесь мы вносим изменения в уже созданное меню, если это необходимо

onOptionsItemSelected - вызывается при нажатии пункта меню. Здесь мы
определяем какой пункт меню был нажат.


В методе onCreateOptionsMenu мы добавляем 6 пунктов меню. Обратим
внимание на параметры метода Add.

Первый параметр – ID группы. В первых трех пунктах он равен нулю, в
оставшихся трех – 1. Т.е. пункты меню copy, paste и exit объединены в группу
с ID = 1. Визуально это никак не проявляется - они не отличаются цветом или
еще чем-либо. ID группы мы будем использовать в
реализации onPrepareOptionsMenu.

Второй параметр – ID пункта меню. В обработчике используется для
определения какой пункт меню был нажат. Будем использовать его
в onOptionsItemSelected.

Третий параметр – определяет позицию пункта меню. Этот параметр
используется для определения порядка пунктов при отображении меню.
Используется сортировка по возрастанию, т.е. от меньшего order к большему.

Четвертый параметр – текст, который будет отображаться на пункте меню.
Тут все понятно.

В метод onPrepareOptionsMenu передается объект Menu и мы можем работать
с ним. В данном примере вызываем setGroupVisible. Этот метод
позволяет скрывать\отображать пункты меню. На вход подается два
параметра – ID группы и boolean-значение. В качестве ID группы мы пишем

- 1 (та самая группа с ID = 1, в которой находятся пункты copy, paste и exit), а
в качестве boolean параметра используем состояние CheckBox. Если он
включен, то пункты меню (из группы с ID = 1) будут отображаться, если
выключен – не будут.

Сохраним все и запустим приложение.
"Обычное" меню:


"Расширенное" меню

В зависимости от состояния CheckBox в меню видно 3 или 6 пунктов.

Обратите внимание на порядок пунктов. Они отсортированы по
параметру order по возрастанию. Если order у нескольких пунктов совпадает,
то эти пункты размещаются в порядке их создания в методе
onCreateOptionsMenu.


При нажатии на какой-либо пункт меню срабатывает
метод onOptionsItemSelected. В нем мы выводим в TextView информацию о
нажатом пункте. Можете сверить эту информацию с тем, что мы кодили при
создании пунктов меню. Все параметры должны совпадать. Порядок, для
удобства, я сделал такой же как и в методе add: groupId, itemId, order, title.
Попробуйте добавить еще несколько пунктов в меню, чтобы их стало больше
шести. И обратите внимание, как они отобразятся.

Для упрощения кода я использовал напрямую цифры для ID групп и ID
пунктов меню. А вообще рекомендуется использовать константы, в
дальнейшем буду использовать их.

XML-меню
Есть еще один, более удобный и предпочтительный способ создания меню - с
использованием xml-файлов, аналогично layout-файлам при создании экрана.
Чтобы получить меню, которые мы создавали программно на этом уроке,
надо создать в папке res/menu файл mymenu.xml:

<?xml version="1.0" encoding="utf-8"?>

<menu

xmlns:android="http://schemas.android.com/apk/res/android">
<item

android:id="@+id/menu_add"

android:title="add">
</item>

<item

android:id="@+id/menu_edit"

android:title="edit">
</item>

<item

android:id="@+id/menu_delete"
android:orderInCategory="3"

android:title="delete">


</item>

<group
android:id="@+id/group1">

<item

android:id="@+id/menu_copy"
android:orderInCategory="1"

android:title="copy">

</item>

<item
android:id="@+id/menu_paste"

android:orderInCategory="2"

android:title="paste">
</item>

<item

android:id="@+id/menu_exit"
android:orderInCategory="4"

android:title="exit">

</item>

</group>
</menu>

Если в папке res нет папки меню, создайте ее. Правой кнопкой на res,
выбирайте New > Android Resource Directory, в Resource type выбирайте menu
и жмите OK.

item - это пункт меню, group - группа. В атрибутах ID используем ту же
схему, что и в ID экранных компонентов, т.е. пишем @+id/<your_ID> и
Eclipse сам создаст эти ID в R.java. Атрибут orderInCategory - это порядок
пунктов, а title - текст.


В методе onCreateOptionsMenu нам теперь не надо вручную кодить создание
каждого пункта, мы просто свяжем menu, который нам дается на вход и наш
xml-файл.

public boolean onCreateOptionsMenu(Menu menu) {

getMenuInflater().inflate(R.menu.mymenu, menu);
return super.onCreateOptionsMenu(menu);

}

С помощью метода getMenuInflater мы получаем MenuInflater и вызываем его
метод inflate. На вход передаем наш файл mymenu.xml из папки res/menu и
объект menu. MenuInflater берет объект menu и наполняет его пунктами
согласно файлу mymenu.xml.

Если захотите скрыть группу, выполняете тот же метод setGroupVisible и
передаете туда R.id.group1 в качестве ID группы.

Подробно атрибуты для xml-файла меню можно посмотреть здесь.

Я вам рекомендую опробовать и потестить оба способа созданию меню.
Программное создание гибче, а xml сокращает код.

**Тема. Контекстное меню**
Цель:

- создадим контекстное меню

Контекстное меню вызывается в Андроид длительным нажатием на каком-
либо экранном компоненте. Обычно оно используется в списках, когда на
экран выводится список однородных объектов (например письма в
почт.ящике) и, чтобы выполнить действие с одним из этих объектов, мы
вызываем контекстное меню для него. Но т.к. списки мы еще не проходили,
сделаем пример попроще и будем вызывать контекстное меню для TextView.

Откроем main.xml и нарисуем там два TextView:

<?xml version="1.0" encoding="utf-8"?>

<LinearLayout


xmlns:android="http://schemas.android.com/apk/res/android"

android:orientation="vertical"
android:layout_width="fill_parent"

android:layout_height="fill_parent">

<TextView
android:layout_height="wrap_content"

android:textSize="26sp"

android:layout_width="wrap_content"

android:id="@+id/tvColor"
android:layout_marginBottom="50dp"

android:layout_marginTop="50dp"

android:text="Text color">
</TextView>

<TextView

android:layout_width="fill_parent"
android:layout_height="wrap_content"

android:textSize="22sp"

android:id="@+id/tvSize"

android:text="Text size">
</TextView>

</LinearLayout>

Для первого TextView мы сделаем контекстное меню, с помощью которого
будем менять цвет текста. Для второго – будем менять размер текста.

Принцип создания контекстного меню похож на создание обычного меню.
Но есть и отличия.

Метод создания onCreateContextMenu вызывается каждый раз перед показом
меню. На вход ему передается:

- ContextMenu, в который мы будем добавлять пункты
- View - элемент экрана, для которого вызвано контекстное меню
- ContextMenu.ContextMenuInfo – содержит доп.информацию, когда


контекстное меню вызвано для элемента списка. Пока мы это не используем,
но, когда будем изучать списки, увидим, что штука полезная.

Метод обработки onContextItemSelected аналогичный
методу onOptionsItemSelected для обычного меню. На вход
передается MenuItem – пункт меню, который был нажат.

Также нам понадобится третий метод registerForContextMenu. На вход ему
передается View и это означает, что для этой View необходимо создавать
контекстное меню. Если не выполнить этот метод, контекстное меню для
View создаваться не будет.

Давайте кодить, открываем MainActivity.java. Опишем и найдем TextView и
укажем, что необходимо создавать для них контекстное меню.

TextView tvColor, tvSize;

/** Called when the activity is first created. */

@Override

public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);

setContentView(R.layout.main);

tvColor = (TextView) findViewById(R.id.tvColor);

tvSize = (TextView) findViewById(R.id.tvSize);

// для tvColor и tvSize необходимо создавать контекстное меню
registerForContextMenu(tvColor);

registerForContextMenu(tvSize);

## }


Теперь опишем создание контекстных меню. Используем константы для
хранения ID пунктов меню.
final int MENU_COLOR_RED = 1;

final int MENU_COLOR_GREEN = 2;

final int MENU_COLOR_BLUE = 3;

final int MENU_SIZE_22 = 4;

final int MENU_SIZE_26 = 5;

final int MENU_SIZE_30 = 6;
И создаем

@Override

public void onCreateContextMenu(ContextMenu menu, View v,
ContextMenuInfo menuInfo) {

// TODO Auto-generated method stub

switch (v.getId()) {
case R.id.tvColor:

menu.add(0, MENU_COLOR_RED, 0, "Red");

menu.add(0, MENU_COLOR_GREEN, 0, "Green");

menu.add(0, MENU_COLOR_BLUE, 0, "Blue");
break;

case R.id.tvSize:

menu.add(0, MENU_SIZE_22, 0, "22");
menu.add(0, MENU_SIZE_26, 0, "26");

menu.add(0, MENU_SIZE_30, 0, "30");

break;

}
}

Обратите внимание, что мы по ID определяем View, для которого
вызвано контекстное меню и в зависимости от этого создаем определенное


меню. Т.е. если контекстное меню вызвано для tvColor, то мы создаем меню с
перечислением цветов, а если для tvSize – с размерами шрифта.
В качестве ID пунктов мы использовали константы. Группировку и
сортировку не используем, поэтому используем нули в качестве
соответствующих параметров.
Можно все сохранить и запустить. При долгом нажатии на TextView должны
появляться контекстные меню.

Но нажатие на них ничего не дает, т.к. мы не прописали обработку в методе
onContextItemSelected. Давайте пропишем:

@Override

public boolean onContextItemSelected(MenuItem item) {

// TODO Auto-generated method stub
switch (item.getItemId()) {

// пункты меню для tvColor

case MENU_COLOR_RED:
tvColor.setTextColor(Color.RED);

tvColor.setText("Text color = red");

break;
case MENU_COLOR_GREEN:

tvColor.setTextColor(Color.GREEN);


tvColor.setText("Text color = green");

break;
case MENU_COLOR_BLUE:

tvColor.setTextColor(Color.BLUE);

tvColor.setText("Text color = blue");
break;

// пункты меню для tvSize

case MENU_SIZE_22:

tvSize.setTextSize(22);
tvSize.setText("Text size = 22");

break;

case MENU_SIZE_26:
tvSize.setTextSize(26);

tvSize.setText("Text size = 26");

break;
case MENU_SIZE_30:

tvSize.setTextSize(30);

tvSize.setText("Text size = 30");

break;
}

return super.onContextItemSelected(item);

}
В этом методе мы определяем по ID, какой пункт меню был нажат. И
выполняем соответствующие действия: меняем цвет текста для tvColor или
размер шрифта для tvSize. Сохраняем, запускаем и проверяем, что
контекстные меню теперь реагируют на нажатия и делают то, что от них
требуется.


Для расширения кругозора я хотел бы еще кое-что написать по этой теме.
Возможно, это покажется пока сложноватым, так что если вдруг будет
непонятно, ничего страшного. Итак, мысли вслух.

Мы использовали метод registerForContextMenu (View view) для включения
контекстного меню для определенного View. Этот метод принадлежит классу
Activity. Я посмотрел исходники этого метода, там написано следующее:

public void registerForContextMenu(View view) {

view.setOnCreateContextMenuListener(this);

}
Вспоминаем наш урок по обработчикам и смотрим хелп по
методу setOnCreateContextMenuListener (View.OnCreateContextMenuListener
l). Получается, что View в качестве обработчика создания контекстного меню
использует объект this. В данном случае, этот код в Activity, значит this – это
Activity и есть. Т.е. когда View хочет показать контекстное меню, оно
обращается к обработчику (Activity), а он уже выполняет свой
метод onCreateContextMenu. Т.е. тот же самый принцип, что и при обычном
нажатии (Click).

И строка в MainActivity.java:
registerForContextMenu(tvColor);

абсолютно равнозначна этой строке:

tvColor.setOnCreateContextMenuListener(this);
Вообще мы можем создать свой объект, реализующий интерфейс
View.OnCreateContextMenuListener и использовать его вместо Activity в
качестве обработчика создания контекстного меню.

Не забывайте, что для контекстного меню вы также можете использовать
XML-способ, который был рассмотрен в конце прошлого урока. Попробуйте
сделать этот же урок, но уже с использованием XML-меню.

Полный код урока:

public class MainActivity extends Activity {

final int MENU_COLOR_RED = 1;


final int MENU_COLOR_GREEN = 2;

final int MENU_COLOR_BLUE = 3;

final int MENU_SIZE_22 = 4;

final int MENU_SIZE_26 = 5;
final int MENU_SIZE_30 = 6;

TextView tvColor, tvSize;

/** Called when the activity is first created. */

@Override

public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);

setContentView(R.layout.main);

tvColor = (TextView) findViewById(R.id.tvColor);

tvSize = (TextView) findViewById(R.id.tvSize);

// для tvColor и tvSize необходимо создавать контекстное меню
registerForContextMenu(tvColor);

registerForContextMenu(tvSize);

}

@Override

public void onCreateContextMenu(ContextMenu menu, View v,

ContextMenuInfo menuInfo) {
// TODO Auto-generated method stub

switch (v.getId()) {


case R.id.tvColor:

menu.add(0, MENU_COLOR_RED, 0, "Red");
menu.add(0, MENU_COLOR_GREEN, 0, "Green");

menu.add(0, MENU_COLOR_BLUE, 0, "Blue");

break;
case R.id.tvSize:

menu.add(0, MENU_SIZE_22, 0, "22");

menu.add(0, MENU_SIZE_26, 0, "26");

menu.add(0, MENU_SIZE_30, 0, "30");
break;

}

}

@Override

public boolean onContextItemSelected(MenuItem item) {
// TODO Auto-generated method stub

switch (item.getItemId()) {

// пункты меню для tvColor

case MENU_COLOR_RED:
tvColor.setTextColor(Color.RED);

tvColor.setText("Text color = red");

break;
case MENU_COLOR_GREEN:

tvColor.setTextColor(Color.GREEN);

tvColor.setText("Text color = green");

break;
case MENU_COLOR_BLUE:

tvColor.setTextColor(Color.BLUE);


tvColor.setText("Text color = blue");

break;
// пункты меню для tvSize

case MENU_SIZE_22:

tvSize.setTextSize(22);
tvSize.setText("Text size = 22");

break;

case MENU_SIZE_26:

tvSize.setTextSize(26);
tvSize.setText("Text size = 26");

break;

case MENU_SIZE_30:
tvSize.setTextSize(30);

tvSize.setText("Text size = 30");

break;
}

return super.onContextItemSelected(item);

}

}


